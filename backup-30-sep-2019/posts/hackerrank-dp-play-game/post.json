{
    "filepath": "./posts/hackerrank-dp-play-game/post.json",
    "title": "An Easy Dynamic Programming Problem and Solution Analysis",
    "abstract": "Analysing how I approached and solved a dynamic programming problem. [Easy]",
    "created": "1st September, 2017",
    "modified": "1st September, 2017",
    "published": true,
    "categories": [
        "Coding"
    ],
    "content": "<p>After about one year abstinence from competitive coding, I was busy with Ironscript and the job lately,\nI found some time to do some fun stuff yesterday (apparently I got ill with Hepatitis-E and was advised to rest, resting\nturned out to be boring). So I decided to solve a problem on Dynamic Programming from <a href=\"https://hackerrank.com\">HackerRank</a>.\nThe problem goes like the following.</p>\n\n<h4>Problem Statement</h4>\n\n<p>You and your friend decide to play a game using a stack consisting of <code>N</code> bricks.\nIn this game, you can alternatively remove 1, 2 or 3 bricks from the top, and the numbers\netched on the removed bricks are added to your score. You have to play so that you obtain\nthe maximum possible score. <em>It is given that your friend will also play optimally and you make the first move.</em></p>\n\n<p><code>N</code> is of the order of 100,000 and the output should be a single integer which is the maximum score\nobtainale by you.</p>\n\n<h4>So how do I solve it ?</h4>\n\n<p>Here the input is a sequence <code>seq[0:N]</code> of integers of length <code>N</code>. From this sequence the player is allowed to take\n1 or 2 or 3 values at a time. Let <code>f(seq)</code> be the function that returns the maximum obtainable score by the player who\ntakes the first move for any sequence.</p>\n\n<p>If the player who moves first takes a few (1 or 2 or 3) values from the sequence then he/she gets the sum of those values\nplus the maximum obtainable score after the opponent makes his optimal move; i.e. on the next move the opponent gets the\nmaximum obtainable score of the rest of the sequence and our player gets what&#39;s left.</p>\n\n<p>Mathematically, we can express it as:</p>\n\n<pre><code>  f (seq) = max (\n              seq[0] + sum( seq[1:N] ) - f( seq[1:N] ) ,\n              seq[0] + seq[1] + sum( seq[2:N] ) - f( seq[2:N] ) ,\n              seq[0] + seq[1] + seq[2] + sum( seq[3:N] ) - f( seq[3:N] )\n            )</code></pre>\n\n<p>i.e. the player should choose to pick 1 or 2 or 3 values depending on which move maximizes his score for the rest of\nthe game.</p>\n\n<p>In a traditional dynamic programming solution, we can model this function using 2 arrays of length <code>N</code> each, one array\nto memorize the <code>sum</code> (because sum of a sequence can be described recursively as sum of a value and the subsequence\nwithout that value) function and another array to memorize the function <code>f</code>. But if we observe closely, we can see that\nour solution depends on the 3 consecutive values of <code>sum</code> and <code>f</code> at a time. Therefore we can reduce the arrays of length\n<code>N</code> to arrays of length <code>4</code> (the current value and the 3 consecutive dependent values) and save a lot of memory.</p>\n\n<p><strong>The following is a C++ program implementing the solution described.</strong></p>\n\n<pre><code>  #include &lt;iostream&gt;\n  #include &lt;vector&gt;\n  using namespace std;\n\n  unsigned long long max (unsigned long long a, unsigned long long b, unsigned long long c) {\n\n\n    if (a &gt; b &amp;&amp; a &gt; c) return a;\n    if (b &gt; c) return b;\n    return c;\n  }\n\n  int main () {\n    int T, N;\n    unsigned long long sum[4], dp[4];\n    cin &gt;&gt; T;\n    while (T--) {\n      cin &gt;&gt; N;\n      vector &lt;int&gt; bricks (N+3, 0);\n      for (int i=0; i&lt;N; i++) cin &gt;&gt; bricks[i];\n\n      for (int i=0; i&lt;4; i++) {\n        sum[i] = 0;\n        dp[i] = 0;\n      }\n\n      for (int i=N-1; i&gt;=0; i--) {\n        sum[i % 4] = sum[(i+1) % 4] + bricks[i];\n        dp[i % 4] = max (\n          bricks[i] + sum[(i+1) % 4] - dp[(i+1) % 4],\n          bricks[i] + bricks[i+1] + sum[(i+2) % 4] - dp[(i+2) % 4],\n          bricks[i] + bricks[i+1] + bricks[i+2] + sum[(i+3) % 4] - dp[(i+3) % 4]\n        );\n      }\n      cout &lt;&lt; dp[0] &lt;&lt; endl;\n    }\n    return 0;\n  }</code></pre>"
}
title : An Easy Dynamic Programming Problem and Solution Analysis
abstract : Analysing how I approached and solved a dynamic programming problem. [Easy]
categories : Coding

----------------------------------------------------------------------

After about one year abstinence from competitive coding, I was busy with Ironscript and the job lately,
I found some time to do some fun stuff yesterday (apparently I got ill with Hepatitis-E and was advised to rest, resting
turned out to be boring). So I decided to solve a problem on Dynamic Programming from [HackerRank](https://hackerrank.com).
The problem goes like the following.

#### Problem Statement

You and your friend decide to play a game using a stack consisting of `N` bricks.
In this game, you can alternatively remove 1, 2 or 3 bricks from the top, and the numbers
etched on the removed bricks are added to your score. You have to play so that you obtain
the maximum possible score. *It is given that your friend will also play optimally and you make the first move.*

`N` is of the order of 100,000 and the output should be a single integer which is the maximum score
obtainale by you.

#### So how do I solve it ?

Here the input is a sequence `seq[0:N]` of integers of length `N`. From this sequence the player is allowed to take
1 or 2 or 3 values at a time. Let `f(seq)` be the function that returns the maximum obtainable score by the player who
takes the first move for any sequence.

If the player who moves first takes a few (1 or 2 or 3) values from the sequence then he/she gets the sum of those values
plus the maximum obtainable score after the opponent makes his optimal move; i.e. on the next move the opponent gets the
maximum obtainable score of the rest of the sequence and our player gets what's left.

Mathematically, we can express it as:



      f (seq) = max (
                  seq[0] + sum( seq[1:N] ) - f( seq[1:N] ) ,
                  seq[0] + seq[1] + sum( seq[2:N] ) - f( seq[2:N] ) ,
                  seq[0] + seq[1] + seq[2] + sum( seq[3:N] ) - f( seq[3:N] )
                )



i.e. the player should choose to pick 1 or 2 or 3 values depending on which move maximizes his score for the rest of
the game.

In a traditional dynamic programming solution, we can model this function using 2 arrays of length `N` each, one array
to memorize the `sum` (because sum of a sequence can be described recursively as sum of a value and the subsequence
without that value) function and another array to memorize the function `f`. But if we observe closely, we can see that
our solution depends on the 3 consecutive values of `sum` and `f` at a time. Therefore we can reduce the arrays of length
`N` to arrays of length `4` (the current value and the 3 consecutive dependent values) and save a lot of memory.

**The following is a C++ program implementing the solution described.**



      #include <iostream>
      #include <vector>
      using namespace std;

      unsigned long long max (unsigned long long a, unsigned long long b, unsigned long long c) {


        if (a > b && a > c) return a;
        if (b > c) return b;
        return c;
      }

      int main () {
        int T, N;
        unsigned long long sum[4], dp[4];
        cin >> T;
        while (T--) {
          cin >> N;
          vector <int> bricks (N+3, 0);
          for (int i=0; i<N; i++) cin >> bricks[i];

          for (int i=0; i<4; i++) {
            sum[i] = 0;
            dp[i] = 0;
          }

          for (int i=N-1; i>=0; i--) {
            sum[i % 4] = sum[(i+1) % 4] + bricks[i];
            dp[i % 4] = max (
              bricks[i] + sum[(i+1) % 4] - dp[(i+1) % 4],
              bricks[i] + bricks[i+1] + sum[(i+2) % 4] - dp[(i+2) % 4],
              bricks[i] + bricks[i+1] + bricks[i+2] + sum[(i+3) % 4] - dp[(i+3) % 4]
            );
          }
          cout << dp[0] << endl;
        }
        return 0;
      }



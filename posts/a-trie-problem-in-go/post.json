{
    "filepath": "./posts/a-trie-problem-in-go/post.json",
    "title": "Solving a string prefix problem using Trie in golang",
    "abstract": "A few days ago we conducted a learning session on golang for my team at work. It was a short session covering<br/>the basics of the language. Since then, I had been thinking of writing a series of blogposts/tutorial<span class=\"ellipsis\">...</span>",
    "id": "a-trie-problem-in-go",
    "created": "June 19, 2022",
    "modified": "June 19, 2022",
    "published": true,
    "categories": [
        "golang",
        "datastructures",
        "algorithms",
        "programming"
    ],
    "href": "https://gnsp.in/blog/posts/a-trie-problem-in-go/index.html",
    "cover_image": "https://gnsp.in/blog/posts/a-trie-problem-in-go/assets/cover.jpg",
    "content": "<p>A few days ago we conducted a learning session on golang for my team at work. It was a short session covering\nthe basics of the language. Since then, I had been thinking of writing a series of blogposts/tutorials about\nusing these basic concepts to solve real algorithmic problems using golang. Today (Sunday, 19th June 2022) I\ncame across this interesting problem about finding matching strings from a list of strings for a given prefix\nwhile browsing through some old folders on my laptop. I had solved this problem in Javascript some 3 years ago;\ntoday I decided to give it a &#39;Go&#39; !</p>\n<h3 id=\"the-problem\">The problem</h3>\n<p>This problem is available on leetcode, here is the <a href=\"https://leetcode.com/problems/search-suggestions-system/\">link</a>.</p>\n<h4 id=\"problem-statement\">Problem statement</h4>\n<p>You are given an array of strings <code>products</code> and a string <code>searchWord</code>.</p>\n<p>Design a system that suggests at most three product names from <code>products</code> after each character of <code>searchWord</code> is typed. \nSuggested products should have common prefix with <code>searchWord</code>. If there are more than three products with a common prefix \nreturn the three lexicographically minimum products.</p>\n<p>Return a <em>list of lists</em> of the suggested products after each character of searchWord is typed.</p>\n<h4 id=\"constraints\">Constraints</h4>\n<ul>\n<li><code>1 &lt;= products.length &lt;= 1000</code></li>\n<li><code>1 &lt;= products[i].length &lt;= 3000</code></li>\n<li><code>1 &lt;= sum(products[i].length) &lt;= 2 * 10^4</code></li>\n<li>All the strings of products are <strong>unique</strong>.</li>\n<li><code>products[i]</code> consists of lowercase English letters.</li>\n<li><code>1 &lt;= searchWord.length &lt;= 1000</code></li>\n<li><code>searchWord</code> consists of lowercase English letters.</li>\n</ul>\n<h4 id=\"example-testcases\">Example testcases</h4>\n<p><strong>Example 1</strong></p>\n<pre><code><span class=\"hljs-symbol\">Input</span>: products = [<span class=\"hljs-string\">\"mobile\"</span>,<span class=\"hljs-string\">\"mouse\"</span>,<span class=\"hljs-string\">\"moneypot\"</span>,<span class=\"hljs-string\">\"monitor\"</span>,<span class=\"hljs-string\">\"mousepad\"</span>], searchWord = <span class=\"hljs-string\">\"mouse\"</span>\n<span class=\"hljs-symbol\">Output</span>: [\n  [<span class=\"hljs-string\">\"mobile\"</span>,<span class=\"hljs-string\">\"moneypot\"</span>,<span class=\"hljs-string\">\"monitor\"</span>],\n  [<span class=\"hljs-string\">\"mobile\"</span>,<span class=\"hljs-string\">\"moneypot\"</span>,<span class=\"hljs-string\">\"monitor\"</span>],\n  [<span class=\"hljs-string\">\"mouse\"</span>,<span class=\"hljs-string\">\"mousepad\"</span>],\n  [<span class=\"hljs-string\">\"mouse\"</span>,<span class=\"hljs-string\">\"mousepad\"</span>],\n  [<span class=\"hljs-string\">\"mouse\"</span>,<span class=\"hljs-string\">\"mousepad\"</span>]\n]</code></pre><p><strong>Example 2</strong></p>\n<pre><code><span class=\"hljs-symbol\">Input</span>: products = [<span class=\"hljs-string\">\"havana\"</span>], searchWord = <span class=\"hljs-string\">\"havana\"</span>\n<span class=\"hljs-symbol\">Output</span>: [[<span class=\"hljs-string\">\"havana\"</span>],[<span class=\"hljs-string\">\"havana\"</span>],[<span class=\"hljs-string\">\"havana\"</span>],[<span class=\"hljs-string\">\"havana\"</span>],[<span class=\"hljs-string\">\"havana\"</span>],[<span class=\"hljs-string\">\"havana\"</span>]]</code></pre><p><strong>Example 3</strong></p>\n<pre><code><span class=\"hljs-symbol\">Input</span>: products = [<span class=\"hljs-string\">\"bags\"</span>,<span class=\"hljs-string\">\"baggage\"</span>,<span class=\"hljs-string\">\"banner\"</span>,<span class=\"hljs-string\">\"box\"</span>,<span class=\"hljs-string\">\"cloths\"</span>], searchWord = <span class=\"hljs-string\">\"bags\"</span>\n<span class=\"hljs-symbol\">Output</span>: [[<span class=\"hljs-string\">\"baggage\"</span>,<span class=\"hljs-string\">\"bags\"</span>,<span class=\"hljs-string\">\"banner\"</span>],[<span class=\"hljs-string\">\"baggage\"</span>,<span class=\"hljs-string\">\"bags\"</span>,<span class=\"hljs-string\">\"banner\"</span>],[<span class=\"hljs-string\">\"baggage\"</span>,<span class=\"hljs-string\">\"bags\"</span>],[<span class=\"hljs-string\">\"bags\"</span>]]</code></pre><h3 id=\"solving-the-problem\">Solving the problem</h3>\n<p>This problem is about finding matching strings from a list of strings <code>products</code> for each of the\nprefixes obtained from <code>searchWord</code> taking one character at a time and appending it to the previous\nprefix. For example, if the <code>searchWord</code> is <code>&quot;cat&quot;</code>, then the prefixes for which we need to find\nmatching strings will be <code>[&quot;c&quot;, &quot;ca&quot;, &quot;cat&quot;]</code>. For each of these prefixes we are to find 3 matching strings\n(in lexicographical order, ascending) from the array of strings <code>products</code>.</p>\n<p>This problem can be solved efficiently by using the datastructure <strong>Trie</strong> aka <strong>Prefix tree</strong>; by efficiently\nI mean with the worst case time conplexity of <em>O(M+n)</em> where <em>M</em> is the number of characters in the\narray <code>products</code> and <em>n</em> is the length of <code>searchWord</code>. Before we start implementing the solution, let&#39;s have\na quick overview of the <strong>Trie</strong> datastructure.</p>\n<h4 id=\"trie\">Trie</h4>\n<p>A trie is a k-ary search tree. It stores multiple words/strings by taking each cahracter as a node. If multiple\nwords have the same prefix then they follow the same path from the root of the trie until the end of the common\nprefix. For example, if the list of words is <code>[&quot;CAT&quot;, &quot;CAN&quot;, &quot;BAT&quot;, &quot;BAG&quot;]</code> then the corresponding trie can be \nvisualised as the following diagram.</p>\n<p><img src=\"https://gnsp.in/blog/posts/a-trie-problem-in-go/assets/trie.png\" alt=\"trie\"></p>\n<p>Here the root node stands for the prefix empty string. As the empty string is a valid prefix for all strings in\nthe list, all of them can be matched from the root node. Then we have the words <code>[&quot;CAT&quot;, &quot;CAN&quot;]</code> that have a common\nprefix <code>&quot;C&quot;</code> and the words <code>[&quot;BAT&quot;, &quot;BAG&quot;]</code> that have a common prefix <code>&quot;B&quot;</code>. Therefore the root node will have 2\nchildren nodes <code>B</code> and <code>C</code>. Similarly each of the children nodes <code>B</code> and <code>C</code> will have one child node each, standing\nfor <code>A</code>; at this point the prefixes for the respective paths would be <code>&quot;BA&quot;</code> and <code>&quot;CA&quot;</code> and so on.</p>\n<p>You can read more about Tries <a href=\"https://en.wikipedia.org/wiki/Trie\">here</a>.</p>\n<h4 id=\"implementing-the-solution\">Implementing the solution</h4>\n<p>In this problem, we want to store only 3 matching words (sorted in lexicographical order) from <code>products</code> at each node.\nSo, each node will have an array of 3 strings to store the matches and a list of pointers to its children.</p>\n<p>Let&#39;s define this trie structure in go. To make things more space efficient, rather than storing the actual matching\nstrings in each node, we can store their indices in the <code>products</code> array and then look up the actual strings using \nthese indices when we need to output the actual strings. The lexicographical ordering can be easily handled by sorting\nthe <code>products</code> array once. (Think why ?) We can create a <code>struct</code> type to define each node of the trie like the following:</p>\n<pre><code class=\"language-go\">type trie <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> {</span>\n  words [<span class=\"hljs-number\">3</span>]<span class=\"hljs-keyword\">int</span>\n  wordsLen <span class=\"hljs-keyword\">int</span>\n  children <span class=\"hljs-built_in\">map</span>[<span class=\"hljs-built_in\">string</span>]*trie\n}</code></pre>\n<p>Here <code>children</code> is a map from strings to pointers to child nodes of the trie node. A tree is a recusrive datastructure,\nand it&#39;s efficient to strore pointers to child nodes on each node of the trie. The <code>wordsLen</code> field is to keep track of\nhow many entries in the <code>words</code> array are valid indices. In golang, <code>int</code> values default to <code>0</code>, and <code>0</code> can be a valid\nindex in the <code>products</code> array even when the <code>0th</code> string in the <code>products</code> is not a matching string for the node. Therefore\nit&#39;s necessary to keep track of where the valid indices end inside the <code>words</code> array.</p>\n<p>As the trie struct has a map field declared inside it and we can not use it before initializing the map, let&#39;s also\nwrite a helper function to create a trie node, initialize the map and return a pointer to the node.</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">newTrie</span> <span class=\"hljs-params\">()</span> *<span class=\"hljs-title\">trie</span></span> {\n  <span class=\"hljs-keyword\">var</span> t trie\n\n  <span class=\"hljs-comment\">// initialize the map</span>\n  t.children = <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]*trie)\n\n  <span class=\"hljs-comment\">// return the pointer to the trie node</span>\n  <span class=\"hljs-keyword\">return</span> &amp;t\n}</code></pre>\n<p>Now that we have the trie structure in place, let&#39;s write a method to insert words into it. If a word is among\nthe 3 lexicographically smallest matching strings for a node, then we need to store its index in the words array\nof that node (and increment the <code>wordsLen</code> field). If we have already stored the 3 lexicographcally minimum matching\nstrings for a node, then we do not need to store the word in that node and we can move to its child nodes recursively.</p>\n<p>The method needs to take the word, its index in the <code>products</code> array and the current character of the word being inserted\ninto the trie node as arguments. If the trie node does not have a child for the current character, then we need to \ncreate a trie node and add it to the <code>children</code> map against the current character.</p>\n<pre><code class=\"language-go\">// Here <span class=\"hljs-keyword\">index</span> <span class=\"hljs-keyword\">is</span> the <span class=\"hljs-keyword\">index</span> of the word <span class=\"hljs-keyword\">in</span> products\n// <span class=\"hljs-keyword\">and</span> pos <span class=\"hljs-keyword\">is</span> the <span class=\"hljs-keyword\">index</span> of the current character being added <span class=\"hljs-keyword\">to</span> the trie\n\nfunc (t *trie) insertWord (word <span class=\"hljs-keyword\">string</span>, <span class=\"hljs-keyword\">index</span> int, pos int) int{\n\n  // <span class=\"hljs-keyword\">if</span> we have <span class=\"hljs-keyword\">not</span> found <span class=\"hljs-number\">3</span> matching strings yet, <span class=\"hljs-keyword\">then</span> store the word (<span class=\"hljs-keyword\">index</span>)\n  <span class=\"hljs-keyword\">if</span> t.wordsLen &lt; <span class=\"hljs-number\">3</span> {\n    t.words[t.wordsLen] = <span class=\"hljs-keyword\">index</span>\n    t.wordsLen += <span class=\"hljs-number\">1</span>\n  }\n\n  // <span class=\"hljs-keyword\">if</span> we have reached the <span class=\"hljs-keyword\">end</span> of the word, <span class=\"hljs-keyword\">then</span> <span class=\"hljs-keyword\">do</span> nothing <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">return</span>\n  <span class=\"hljs-keyword\">if</span> pos == len(word) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n  }\n\n  // get the current character <span class=\"hljs-keyword\">and</span> check <span class=\"hljs-keyword\">if</span> there <span class=\"hljs-keyword\">is</span> a child node <span class=\"hljs-keyword\">for</span> that character\n  // <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span>, <span class=\"hljs-keyword\">then</span> <span class=\"hljs-keyword\">create</span> a new trie node <span class=\"hljs-keyword\">and</span> add it <span class=\"hljs-keyword\">to</span> children\n  ch := <span class=\"hljs-keyword\">string</span>(word[pos])\n  <span class=\"hljs-keyword\">if</span> t.children[ch] == nil {\n    t.children[ch] = newTrie()\n  }\n\n  // recursively <span class=\"hljs-keyword\">insert</span> the word <span class=\"hljs-keyword\">in</span> the corresponding child node\n  t.children[ch].insertWord(word, <span class=\"hljs-keyword\">index</span>, pos+<span class=\"hljs-number\">1</span>)\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n}</code></pre>\n<p>Now that we have the trie structure and the method to insert strings in it, let&#39;s write the function\nto find matching strings for the prefixes. This function will take the array of strings <code>products</code> and\nthe string <code>searchWord</code> as arguments and return a slice of slice of strings with the matching products\nfor each of the prefixes of the <code>searchWord</code>.</p>\n<p>First we need to sort the slice <code>products</code> lexicographically. We can use the native package <code>sort</code> to\ndo this. Then we need to initialize the trie and insert all words in <code>products</code> into it.</p>\n<p>Then we can traverse the trie from root, taking one character at a time from the <code>searchWord</code>. We will\ninitialize the current trie node to <code>root</code> and <code>mismatched</code> flag to <code>false</code>. For each chacater of\nthe <code>searchWord</code> we need to check if the current node has a child corresponding to the character. If \nthere is a child node, then we have a match and we add the <code>words</code> array of that node to the return slice\nand set the child node as the current node. If there is no child node corresponding to the character, then\nwe have a mismatch and all subsequent entries in the return slice will be empty, we will set the <code>mismatched</code>\nflag to <code>true</code> to keep track of this. This is a standard depth first traversal of the trie and it can be\nimplemented like the following.</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">suggestedProducts</span><span class=\"hljs-params\">(products []<span class=\"hljs-keyword\">string</span>, searchWord <span class=\"hljs-keyword\">string</span>)</span> [][]<span class=\"hljs-title\">string</span></span> {\n\n  <span class=\"hljs-comment\">// sort the products slice</span>\n  sort.Strings(products)\n\n  <span class=\"hljs-comment\">// initialize the trie and insert all words in products into it</span>\n  root := *newTrie()\n  <span class=\"hljs-keyword\">for</span> i, word := <span class=\"hljs-keyword\">range</span> products {\n    root.insertWord(word, i, <span class=\"hljs-number\">0</span>)\n  }\n\n  <span class=\"hljs-comment\">// declare the return value, the mismatched flag and current trie node to root</span>\n  <span class=\"hljs-keyword\">var</span> ret [][]<span class=\"hljs-keyword\">string</span>\n  mismatched := <span class=\"hljs-literal\">false</span>\n  t := root\n\n  <span class=\"hljs-comment\">// for each character of the searchWord traverse the trie and find matching words</span>\n  <span class=\"hljs-comment\">// if we are unable to find any matches at any point then we can set the mismatched</span>\n  <span class=\"hljs-comment\">// flag to true and all subsequent matches will be empty slices.</span>\n\n  <span class=\"hljs-keyword\">for</span> _, ch := <span class=\"hljs-keyword\">range</span> searchWord {\n    ch := <span class=\"hljs-keyword\">string</span>(ch)\n    <span class=\"hljs-keyword\">if</span> t.children[ch] == <span class=\"hljs-literal\">nil</span> || mismatched {\n      list := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">string</span>, <span class=\"hljs-number\">0</span>)\n      ret = <span class=\"hljs-built_in\">append</span>(ret, list)\n      mismatched = <span class=\"hljs-literal\">true</span>\n      <span class=\"hljs-keyword\">continue</span>\n    }\n\n    t = *t.children[ch]\n    <span class=\"hljs-keyword\">var</span> list []<span class=\"hljs-keyword\">string</span>\n    <span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">int</span>\n    <span class=\"hljs-keyword\">for</span> i=<span class=\"hljs-number\">0</span>; i&lt;t.wordsLen; i+=<span class=\"hljs-number\">1</span> {\n      list = <span class=\"hljs-built_in\">append</span>(list, products[t.words[i]])\n    }\n    ret = <span class=\"hljs-built_in\">append</span>(ret, list)\n  }\n  <span class=\"hljs-keyword\">return</span> ret\n}</code></pre>\n<p>This concludes our solution. But we need to test it against the example test cases to be sure \nthat it&#39;s indeed a correct solution for the given problem.</p>\n<h4 id=\"testing\">Testing</h4>\n<p>In golang, testing is a really simple process. Go standard library has the testing package to help\nus test and benchmark our implementations with ease. Go automatically detects test files from the\nfilenames; if a filename ends with <code>_test.go</code> then go considers that file to be a test file.\nInside a test file, the functions that start with <code>Test</code> and take one argument of the type <code>*testing.T</code>\nare run by the test runner automatically. Similarly functions that start with <code>Benchmark</code> and take one\nargument of the type <code>*testing.B</code> are run for benchmarking. In case of our solution, we are focused on\nthe unit testing of our solution. So we can write a function <code>TestSuggestedProducts</code> and add our testcases\ninside it. We can use the standard library package <code>reflect</code> to check if the output and expected slices are\ndeeply equal. The following is the complete code for this problem along with the test function.</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">package</span> dsproblems\n\n<span class=\"hljs-keyword\">import</span> (\n  <span class=\"hljs-string\">\"sort\"</span>\n  <span class=\"hljs-string\">\"testing\"</span>\n  <span class=\"hljs-string\">\"reflect\"</span>\n  <span class=\"hljs-string\">\"fmt\"</span>\n)\n\n<span class=\"hljs-keyword\">type</span> trie <span class=\"hljs-keyword\">struct</span> {\n  words [<span class=\"hljs-number\">3</span>]<span class=\"hljs-keyword\">int</span>\n  wordsLen <span class=\"hljs-keyword\">int</span>\n  children <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]*trie\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">newTrie</span> <span class=\"hljs-params\">()</span> *<span class=\"hljs-title\">trie</span></span> {\n  <span class=\"hljs-keyword\">var</span> t trie\n  t.children = <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]*trie)\n  <span class=\"hljs-keyword\">return</span> &amp;t\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(t *trie)</span> <span class=\"hljs-title\">insertWord</span> <span class=\"hljs-params\">(word <span class=\"hljs-keyword\">string</span>, index <span class=\"hljs-keyword\">int</span>, pos <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">int</span></span>{\n  <span class=\"hljs-keyword\">if</span> t.wordsLen &lt; <span class=\"hljs-number\">3</span> {\n    t.words[t.wordsLen] = index\n    t.wordsLen += <span class=\"hljs-number\">1</span>\n  }\n\n  <span class=\"hljs-keyword\">if</span> pos == <span class=\"hljs-built_in\">len</span>(word) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n  }\n\n  ch := <span class=\"hljs-keyword\">string</span>(word[pos])\n  <span class=\"hljs-keyword\">if</span> t.children[ch] == <span class=\"hljs-literal\">nil</span> {\n    t.children[ch] = newTrie()\n  }\n  t.children[ch].insertWord(word, index, pos+<span class=\"hljs-number\">1</span>)\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">suggestedProducts</span><span class=\"hljs-params\">(products []<span class=\"hljs-keyword\">string</span>, searchWord <span class=\"hljs-keyword\">string</span>)</span> [][]<span class=\"hljs-title\">string</span></span> {\n  sort.Strings(products)\n\n  root := *newTrie()\n  <span class=\"hljs-keyword\">for</span> i, word := <span class=\"hljs-keyword\">range</span> products {\n    root.insertWord(word, i, <span class=\"hljs-number\">0</span>)\n  }\n\n  <span class=\"hljs-keyword\">var</span> ret [][]<span class=\"hljs-keyword\">string</span>\n  mismatched := <span class=\"hljs-literal\">false</span>\n  t := root\n  <span class=\"hljs-keyword\">for</span> _, ch := <span class=\"hljs-keyword\">range</span> searchWord {\n    ch := <span class=\"hljs-keyword\">string</span>(ch)\n    <span class=\"hljs-keyword\">if</span> t.children[ch] == <span class=\"hljs-literal\">nil</span> || mismatched {\n      list := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">string</span>, <span class=\"hljs-number\">0</span>)\n      ret = <span class=\"hljs-built_in\">append</span>(ret, list)\n      mismatched = <span class=\"hljs-literal\">true</span>\n      <span class=\"hljs-keyword\">continue</span>\n    }\n\n    t = *t.children[ch]\n    <span class=\"hljs-keyword\">var</span> list []<span class=\"hljs-keyword\">string</span>\n    <span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">int</span>\n    <span class=\"hljs-keyword\">for</span> i=<span class=\"hljs-number\">0</span>; i&lt;t.wordsLen; i+=<span class=\"hljs-number\">1</span> {\n      list = <span class=\"hljs-built_in\">append</span>(list, products[t.words[i]])\n    }\n    ret = <span class=\"hljs-built_in\">append</span>(ret, list)\n  }\n  <span class=\"hljs-keyword\">return</span> ret\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">TestSuggestedProducts</span><span class=\"hljs-params\">(t *testing.T)</span></span> {\n  products := []<span class=\"hljs-keyword\">string</span>{<span class=\"hljs-string\">\"mobile\"</span>,<span class=\"hljs-string\">\"mouse\"</span>,<span class=\"hljs-string\">\"moneypot\"</span>,<span class=\"hljs-string\">\"monitor\"</span>,<span class=\"hljs-string\">\"mousepad\"</span>}\n  searchWord := <span class=\"hljs-string\">\"mouse\"</span>\n  output := [][]<span class=\"hljs-keyword\">string</span>{\n    {<span class=\"hljs-string\">\"mobile\"</span>,<span class=\"hljs-string\">\"moneypot\"</span>,<span class=\"hljs-string\">\"monitor\"</span>}, \n    {<span class=\"hljs-string\">\"mobile\"</span>,<span class=\"hljs-string\">\"moneypot\"</span>,<span class=\"hljs-string\">\"monitor\"</span>}, \n    {<span class=\"hljs-string\">\"mouse\"</span>,<span class=\"hljs-string\">\"mousepad\"</span>}, \n    {<span class=\"hljs-string\">\"mouse\"</span>,<span class=\"hljs-string\">\"mousepad\"</span>}, \n    {<span class=\"hljs-string\">\"mouse\"</span>,<span class=\"hljs-string\">\"mousepad\"</span>},\n  }\n  fmt.Println(output)\n  <span class=\"hljs-keyword\">if</span> !reflect.DeepEqual(suggestedProducts(products, searchWord), output) {\n    t.Fatalf(<span class=\"hljs-string\">\"Failed testcase #1\"</span>)\n  }\n\n  products = []<span class=\"hljs-keyword\">string</span>{<span class=\"hljs-string\">\"havana\"</span>}\n  searchWord = <span class=\"hljs-string\">\"havana\"</span>\n  output = [][]<span class=\"hljs-keyword\">string</span>{\n    {<span class=\"hljs-string\">\"havana\"</span>}, \n    {<span class=\"hljs-string\">\"havana\"</span>}, \n    {<span class=\"hljs-string\">\"havana\"</span>}, \n    {<span class=\"hljs-string\">\"havana\"</span>}, \n    {<span class=\"hljs-string\">\"havana\"</span>}, \n    {<span class=\"hljs-string\">\"havana\"</span>},\n  }\n  fmt.Println(output)\n  <span class=\"hljs-keyword\">if</span> !reflect.DeepEqual(suggestedProducts(products, searchWord), output) {\n    t.Fatalf(<span class=\"hljs-string\">\"Failed testcase #2\"</span>)\n  }\n\n  products = []<span class=\"hljs-keyword\">string</span>{<span class=\"hljs-string\">\"bags\"</span>,<span class=\"hljs-string\">\"baggage\"</span>,<span class=\"hljs-string\">\"banner\"</span>,<span class=\"hljs-string\">\"box\"</span>,<span class=\"hljs-string\">\"cloths\"</span>}\n  searchWord = <span class=\"hljs-string\">\"bags\"</span>\n  output = [][]<span class=\"hljs-keyword\">string</span>{\n    {<span class=\"hljs-string\">\"baggage\"</span>,<span class=\"hljs-string\">\"bags\"</span>,<span class=\"hljs-string\">\"banner\"</span>}, \n    {<span class=\"hljs-string\">\"baggage\"</span>,<span class=\"hljs-string\">\"bags\"</span>,<span class=\"hljs-string\">\"banner\"</span>}, \n    {<span class=\"hljs-string\">\"baggage\"</span>,<span class=\"hljs-string\">\"bags\"</span>}, \n    {<span class=\"hljs-string\">\"bags\"</span>},\n  }\n  fmt.Println(output)\n  <span class=\"hljs-keyword\">if</span> !reflect.DeepEqual(suggestedProducts(products, searchWord), output) {\n    t.Fatalf(<span class=\"hljs-string\">\"Failed testcase #3\"</span>)\n  }\n}</code></pre>\n<p>So, that&#39;s that and we just solved the problem using the trie datastructure in golang. Also, here is an\nimplementation of the same solution in Javascript for reference.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Trie</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(words=[], children={}) {\n    <span class=\"hljs-keyword\">this</span>.words = words;\n    <span class=\"hljs-keyword\">this</span>.children = children;\n  }\n\n  insertWord(word, i, j) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.words.length &lt; <span class=\"hljs-number\">3</span>)\n      <span class=\"hljs-keyword\">this</span>.words.push(i);\n\n    <span class=\"hljs-keyword\">if</span> (j === word.length)\n      <span class=\"hljs-keyword\">return</span>;\n\n    <span class=\"hljs-keyword\">const</span> ch = word.charAt(j);\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.children[ch] === <span class=\"hljs-literal\">undefined</span>) {\n      <span class=\"hljs-keyword\">this</span>.children[ch] = <span class=\"hljs-keyword\">new</span> Trie();\n    }\n    <span class=\"hljs-keyword\">this</span>.children[ch].insertWord(word, i, j+<span class=\"hljs-number\">1</span>);\n  }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">suggest</span>(<span class=\"hljs-params\">words, search</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> sortedWords = [...words];\n  sortedWords.sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a.localeCompare(b));\n\n  <span class=\"hljs-keyword\">const</span> trie = <span class=\"hljs-keyword\">new</span> Trie();\n  sortedWords.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">word, i</span>) =&gt;</span> {\n    trie.insertWord(word, i, <span class=\"hljs-number\">0</span>);\n  });\n\n  <span class=\"hljs-keyword\">return</span> search.split(<span class=\"hljs-string\">''</span>).reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">acc, ch</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (acc.t.children[ch] === <span class=\"hljs-literal\">undefined</span> || acc.done) {\n      acc.ret.push([]);\n      acc.done = <span class=\"hljs-literal\">true</span>;\n      <span class=\"hljs-keyword\">return</span> acc;\n    }\n\n    acc.t = acc.t.children[ch];\n    acc.ret.push(acc.t.words.map(<span class=\"hljs-function\"><span class=\"hljs-params\">ind</span> =&gt;</span> sortedWords[ind]));\n    <span class=\"hljs-keyword\">return</span> acc;\n  }, {<span class=\"hljs-attr\">ret</span>: [], <span class=\"hljs-attr\">t</span>: trie, <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span>}).ret;\n}</code></pre>\n<p>Hoping you had a nice read and learned something new from this article. Have nice days ahead. :)</p>\n"
}
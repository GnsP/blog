<!DOCTYPE html><html lang="en"><head><title>Making a 15-Puzzle Game Using React Hooks | Languoric</title><meta name="viewport" content="initial-scale=1.0"><link rel="stylesheet" href="https://gnsp.in/blog/assets/style.css"><link rel="stylesheet"></head><body><header><h3><a href="https://gnsp.in/blog">Ganesh Prasad's blog</a></h3><nav><ul><li><a href="https://gnsp.in">gnsp.in</a></li></ul></nav></header><main><img class="cover" src="https://gnsp.in/blog/posts/making-a-15-puzzle-game-using-react-hooks-3U24pd/assets/cover.png"><h1>Making a 15-Puzzle Game Using React Hooks</h1><h5>September 12, 2019</h5><ul class="tags"><li><a href="https://gnsp.in/blog/categories/react.html">react</a></li><li><a href="https://gnsp.in/blog/categories/javascript.html">javascript</a></li><li><a href="https://gnsp.in/blog/categories/css.html">css</a></li><li><a href="https://gnsp.in/blog/categories/web.html">web</a></li><li><a href="https://gnsp.in/blog/categories/less.html">less</a></li><li><a href="https://gnsp.in/blog/categories/programming.html">programming</a></li></ul><article><h3 id="we-are-making-a-what-">We are making a what !</h3>
<p>In this article, we will make a simple 15-Puzzle using React Hooks, but what is a 15-Puzzle in the first place ?</p>
<p>As <a href="https://en.wikipedia.org/wiki/15_puzzle">wikipedia</a> defines it,</p>
<p><em>The 15-puzzle (also called Gem Puzzle, Boss Puzzle, Game of Fifteen, Mystic Square and many others) is a sliding puzzle that consists of a frame of numbered square tiles in random order with one tile missing.</em></p>
<p>However, the numbered variant of the puzzle is more or less that mathematical version of it. The ones sold in toy stores are generally the image variant of the game. In this variant, each of the tiles is a small square segment of an image and when the tiles are arranged in the correct order, the complete image takes form. Just like the following image (here the puzzle is in the scrambled state),</p>
<p><img src="https://gnsp.in/blog/posts/making-a-15-puzzle-game-using-react-hooks-3U24pd/assets/demo.png" alt="15 Puzzle"></p>
<p>We will be building this specific variant of the puzzle in this article. When the tiles of this puzzle are arranged in the correct order, we will get an image of Rubeus Hagrid, the Gamekeeper and Keeper of Keys and Grounds of Hogwarts.</p>
<h3 id="a-few-observations">A few observations</h3>
<p>Before we start coding this puzzle, let&#39;s take note of a few things about this puzzle;</p>
<ol>
<li>Only the tiles adjacent to (i.e. sharing an edge with) the empty square in the grid can be moved.</li>
<li>They can be moved only to the position of the empty square.</li>
<li>If we consider the empty square to be an empty tile, then moving an adjacent tile to the empty square can be modeled as swapping the position of the tile with the empty tile.</li>
<li>When the tiles are in the correct order, the <code>i-th</code> tile occupies the square on <code>Math.floor(i / 4)</code>th row and <code>i % 4</code>th column in the grid.</li>
<li>At any point of time, at most one tile can be moved in any one direction.</li>
</ol>
<p>With these observations in mind, let&#39;s start building the puzzle.</p>
<h3 id="scaffolding-and-constants">Scaffolding and constants</h3>
<p>First let&#39;s type out a simple webpage where our react app will be rendered. For simplicity, let&#39;s write than in pug.</p>
<pre><code class="language-pug">html
  head
    title 15 Puzzle (Using React Hooks)
    meta(<span class="hljs-attribute">name</span>=<span class="hljs-string">'viewport'</span>, <span class="hljs-attribute">content</span>=<span class="hljs-string">'initial-scale=1.0'</span>)
    link(<span class="hljs-attribute">rel</span>=<span class="hljs-string">'stylesheet'</span>, <span class="hljs-attribute">href</span>=<span class="hljs-string">'/style.css'</span>)

  body
    #root
    script(<span class="hljs-attribute">type</span>=<span class="hljs-string">'text/javascript'</span>, <span class="hljs-attribute">src</span>=<span class="hljs-string">'https://cdnjs.cloudflare.com/ajax/libs/react/16.8.6/umd/react.production.min.js'</span>)
    script(<span class="hljs-attribute">type</span>=<span class="hljs-string">'text/javascript'</span>, <span class="hljs-attribute">src</span>=<span class="hljs-string">'https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.8.6/umd/react-dom.production.min.js'</span>)
    script(<span class="hljs-attribute">type</span>=<span class="hljs-string">'text/javascript'</span>, <span class="hljs-attribute">src</span>=<span class="hljs-string">'/index.js'</span>)</code></pre>
<p>With this webpage structure in place, let&#39;s define some constants and utility in the <code>index.js</code>.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> NUM_ROWS = <span class="hljs-number">4</span>;
<span class="hljs-keyword">const</span> NUM_COLS = <span class="hljs-number">4</span>;
<span class="hljs-keyword">const</span> NUM_TILES = NUM_ROWS * NUM_COLS;
<span class="hljs-keyword">const</span> EMPTY_INDEX = NUM_TILES - <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> SHUFFLE_MOVES_RANGE = [<span class="hljs-number">60</span>, <span class="hljs-number">80</span>];
<span class="hljs-keyword">const</span> MOVE_DIRECTIONS = [<span class="hljs-string">'up'</span>, <span class="hljs-string">'down'</span>, <span class="hljs-string">'left'</span>, <span class="hljs-string">'right'</span>];

function rand (<span class="hljs-built_in">min</span>, <span class="hljs-built_in">max</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span> + Math.<span class="hljs-built_in">floor</span>(Math.<span class="hljs-built_in">random</span>() * (<span class="hljs-built_in">max</span> - <span class="hljs-built_in">min</span> + <span class="hljs-number">1</span>));
}</code></pre>
<p>Here the <code>rand</code> function generates a random integer between <code>min</code> and <code>max</code> (inclusive). And the constant <code>SHUFFLE_MOVES_RANGE</code> defines the minimum and maximum number of random moves we want to execute in order to scramble the puzzle board. <code>EMPTY_INDEX</code> is the index of the empty tile. When all the tiles are in the correct order, the bottom-right square, i.e. the 16th square (array index 15) will be the empty one.</p>
<h3 id="defining-the-gamestate">Defining the <code>GameState</code></h3>
<p>Now let&#39;s write the logic for the puzzle and encapsulate that in a class called <code>GameState</code>. This <code>GameState</code> class should be a <a href="https://en.wikipedia.org/wiki/Singleton_pattern">singleton</a>, because at any point of time there should be only one game running inside the app. So, let&#39;s write that bit of logic first. </p>
<p>To make the class singleton, we will define a static property called <code>instance</code> which will hold the reference to the current instance of the class and a static method <code>getInstance</code> which will return the current instance if that exists, otherwise it will create a new instance and return that to us.</p>
<pre><code class="language-js">class GameState {
 <span class="hljs-keyword"> static</span><span class="hljs-built_in"> instance </span>= null;

 <span class="hljs-keyword"> static</span> getInstance () {
   <span class="hljs-built_in"> if </span>(!GameState.instance) GameState.instance =<span class="hljs-built_in"> new </span>GameState();
   <span class="hljs-built_in"> return </span>GameState.instance;
  }
}</code></pre>
<p>Inside the <code>GameState</code> we want to keep track of the current state of the board, the number of moves the user has played and a <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">stack</a> of previous board states, so that the user can undo his/her current move and get to the previous state. </p>
<p>Here the most important piece of information, that we are storing, is the state of the puzzle board. Let&#39;s model it first. </p>
<p>The puzzle board is a set of 16 tiles (including the empty tile). At any point of time, each tile is at a certain position in the grid. The position of a tile can be represented by 2 integers denoting the <code>row index</code> and the <code>column index</code>. We can model this as an Array of integer pairs like the following (the following is the representation of the board where the tiles are in the correct order):</p>
<pre><code class="language-js">[
  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], // <span class="hljs-number">1</span>st tile is at <span class="hljs-number">1</span>st row, <span class="hljs-number">1</span>st column
  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], // <span class="hljs-number">2</span>nd tile is at <span class="hljs-number">1</span>st row, <span class="hljs-number">2</span>nd column
  [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">3</span>], // <span class="hljs-number">4</span>th tile is at <span class="hljs-number">1</span>st row, <span class="hljs-number">4</span>th column
  [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], // <span class="hljs-number">5</span>th tile is at <span class="hljs-number">2</span>nd row, <span class="hljs-number">1</span>st column
  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
  ...
  [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>],
  [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], // <span class="hljs-number">16</span>th tile is at <span class="hljs-number">4</span>th row, <span class="hljs-number">4</span>th column (this is the empty tile)
]</code></pre>
<p>Let&#39;s write a static method to generate a board state where the tiles are in correct order, remember that when the tiles are in the correct order, the <code>i-th</code> tile is at <code>Math.floor(i / 4) th</code> row and <code>i % 4</code>th column.</p>
<p>Also, when the puzzle is solved, the tiles are in the correct order. So let&#39;s define a static property called <code>solvedBoard</code> which will store the solved state of the board.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameState</span> </span>{
  <span class="hljs-comment">// ...</span>

  <span class="hljs-keyword">static</span> getNewBoard () {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>(NUM_TILES).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function">(<span class="hljs-params">x, index</span>) =&gt;</span> [
      <span class="hljs-built_in">Math</span>.floor(index / NUM_ROWS), 
      index % NUM_COLS
    ]);
  }

  <span class="hljs-keyword">static</span> solvedBoard = GameState.getNewBoard();
}</code></pre>
<p>When a game starts, </p>
<ol>
<li>the move counter is set to 0, </li>
<li>the stack of previous states is empty, and </li>
<li>the board is at the ordered state. </li>
</ol>
<p>Then from this state, we shuffle / scramble the board before presenting it to the user to solve. Let&#39;s write that. At this point, we will skip writing the method to shuffle / scramble the board. We will just write a stub in its place for the time being.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameState</span> </span>{
  <span class="hljs-comment">// ...</span>

  <span class="hljs-keyword">constructor</span> () {
    <span class="hljs-keyword">this</span>.startNewGame();
  }

  startNewGame () {
    <span class="hljs-keyword">this</span>.moves = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.board = GameState.getNewBoard();
    <span class="hljs-keyword">this</span>.stack = [];
    <span class="hljs-keyword">this</span>.shuffle(); <span class="hljs-comment">// we are still to define this method, </span>
                    <span class="hljs-comment">// let's put a stub in its place for now</span>
  }

  shuffle () {
    <span class="hljs-comment">// set a flag that we are to shuffle the board</span>
    <span class="hljs-keyword">this</span>.shuffling = <span class="hljs-literal">true</span>;

    <span class="hljs-comment">// Do some shuffling here ...</span>

    <span class="hljs-comment">// unset the flag after we are done</span>
    <span class="hljs-keyword">this</span>.shuffling = <span class="hljs-literal">false</span>;
  }
}</code></pre>
<p>Now, let&#39;s define the methods to move the tiles around. Firstly, we need to determine if a certain tile can be moved or not. Let&#39;s assume the <code>i-th</code> tile is at position <code>(r, c)</code> now. Then the <code>i-th</code> tile can be moved, if ad only if the empty-tile, i.e. the <code>16th</code> tile is currently positioned adjacent to it. To be adjacent, two tiles must be in the same row or same column, and if they are in the same row, then the difference of their column indices must be equal to one, and if they are in the same column, then the difference of their row indices must be equal to one.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameState</span> </span>{
  <span class="hljs-comment">// ...</span>

  canMoveTile (index) {
    <span class="hljs-comment">// if the tile index is invalid, we can't move it</span>
    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= NUM_TILES) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-comment">// get the current position of the tile and the empty tile</span>
    const tilePos = <span class="hljs-keyword">this</span>.board[index];
    const emptyPos = <span class="hljs-keyword">this</span>.board[EMPTY_INDEX];

    <span class="hljs-comment">// if they are in the same row, then difference in their </span>
    <span class="hljs-comment">// column indices must be 1 </span>
    <span class="hljs-keyword">if</span> (tilePos[<span class="hljs-number">0</span>] === emptyPos[<span class="hljs-number">0</span>])
      <span class="hljs-keyword">return</span> Math.abs(tilePos[<span class="hljs-number">1</span>] - emptyPos[<span class="hljs-number">1</span>]) === <span class="hljs-number">1</span>;

    <span class="hljs-comment">// if they are in the same column, then difference in their</span>
    <span class="hljs-comment">// row indices must be 1</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tilePos[<span class="hljs-number">1</span>] === emptyPos[<span class="hljs-number">1</span>])
      <span class="hljs-keyword">return</span> Math.abs(tilePos[<span class="hljs-number">0</span>] - emptyPos[<span class="hljs-number">0</span>]) === <span class="hljs-number">1</span>;

    <span class="hljs-comment">// otherwise they are not adjacent</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
}</code></pre>
<p>Actually moving a tile to the empty square is much easier, we just need to swap the positions of that tile and that of the empty tile. And, we need to do a bit of book keeping, that is -- incrementing the moves counter and pushing the state of the board before the move into the stack. (If we are in the shuffling phase, we don&#39;t want to count the moves or push the state into the stack).</p>
<p>If the board is already solved, we want to freeze the board and disallow further movement of tiles. But at this point, we will not implement the method to check if the board is already solved or not. In place of the actual method, we will write a stub.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameState</span> </span>{
  <span class="hljs-comment">// ...</span>

  moveTile (index) {
    <span class="hljs-comment">// if we are not shuffling, and the board is already solved, </span>
    <span class="hljs-comment">// then we don't need to move anything</span>
    <span class="hljs-comment">// Note that, the isSolved method is not defined yet</span>
    <span class="hljs-comment">// let's stub that to return false always, for now</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.shuffling &amp;&amp; <span class="hljs-keyword">this</span>.isSolved()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-comment">// if the tile can not be moved in the first place ...</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.canMoveTile(index)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-comment">// Get the positions of the tile and the empty tile</span>
    const emptyPosition = [...<span class="hljs-keyword">this</span>.board[EMPTY_INDEX]];
    const tilePosition = [...<span class="hljs-keyword">this</span>.board[index]];

    <span class="hljs-comment">// copy the current board and swap the positions</span>
    let boardAfterMove = [...<span class="hljs-keyword">this</span>.board];    
    boardAfterMove[EMPTY_INDEX] = tilePosition;
    boardAfterMove[index] = emptyPosition;

    <span class="hljs-comment">// update the board, moves counter and the stack</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.shuffling) <span class="hljs-keyword">this</span>.stack.push(<span class="hljs-keyword">this</span>.board);
    <span class="hljs-keyword">this</span>.board = boardAfterMove;
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.shuffling) <span class="hljs-keyword">this</span>.moves += <span class="hljs-number">1</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  isSolved () {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// stub</span>
  }
}</code></pre>
<p>From observation, we know that, at any point of time at most one tile can be moved in any one direction. Therefore, if we are given the direction of the movement, we can determine which tile to move. For example, if we are given that the direction of movement is upward, then only the tile immediately below the empty square can be moved. Similarly, if the direction of movement is given to be towards left, then the tile immediately right of the empty square is to be moved. Let&#39;s write a method that will deduce which tile to move, from the given direction of movement, and move it.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameState</span> </span>{
  <span class="hljs-comment">// ...</span>

  moveInDirection (dir) {
    <span class="hljs-comment">// get the position of the empty square</span>
    const epos = <span class="hljs-keyword">this</span>.board[EMPTY_INDEX];

    <span class="hljs-comment">// deduce the position of the tile, from the direction</span>
    <span class="hljs-comment">// if the direction is 'up', we want to move the tile </span>
    <span class="hljs-comment">// immediately below empty, if direction is 'down', then </span>
    <span class="hljs-comment">// the tile immediately above empty and so on  </span>
    const posToMove = dir === <span class="hljs-string">'up'</span> ? [epos[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>, epos[<span class="hljs-number">1</span>]]
      : dir === <span class="hljs-string">'down'</span> ? [epos[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>, epos[<span class="hljs-number">1</span>]]
      : dir === <span class="hljs-string">'left'</span> ? [epos[<span class="hljs-number">0</span>], epos[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]
      : dir === <span class="hljs-string">'right'</span> ? [epos[<span class="hljs-number">0</span>], epos[<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>]
      : epos;

    <span class="hljs-comment">// find the index of the tile currently in posToMove</span>
    let tileToMove = EMPTY_INDEX;
    <span class="hljs-keyword">for</span> (let i=<span class="hljs-number">0</span>; i&lt;NUM_TILES; i++) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.board[i][<span class="hljs-number">0</span>] === posToMove[<span class="hljs-number">0</span>] &amp;&amp; <span class="hljs-keyword">this</span>.board[i][<span class="hljs-number">1</span>] === posToMove[<span class="hljs-number">1</span>]) {
        tileToMove = i;
        <span class="hljs-keyword">break</span>;
      }
    }

    <span class="hljs-comment">// move the tile</span>
    <span class="hljs-keyword">this</span>.moveTile(tileToMove);
  }
}</code></pre>
<p>Now that we have the tile moving logic in place, let&#39;s write the method to undo the previous move. This is simple, we just need to pop the previous state from the stack and restore it. Also, we need to decrement the moves counter.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameState</span> </span>{
  <span class="hljs-comment">// ...</span>

  undo () {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stack.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.board = <span class="hljs-keyword">this</span>.stack.pop();
    <span class="hljs-keyword">this</span>.moves -= <span class="hljs-number">1</span>;
  }
}</code></pre>
<p>At this point, we have most of the game logic in place, with the exception of <code>shuffle</code> and <code>isSloved</code> methods, which are currently stubs. Let&#39;s write those methods now. For simplicity we will execute a number of random moves on the board to shuffle it. And to check if the board is solved, we will simply compare the current state of the board with the static property <code>solvedBoard</code> that we had defined earlier.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameState</span> </span>{
  <span class="hljs-comment">// ...</span>

  shuffle () {
    <span class="hljs-keyword">this</span>.shuffling = <span class="hljs-literal">true</span>;
    let shuffleMoves = rand(...SHUFFLE_MOVES_RANGE);
    <span class="hljs-keyword">while</span> (shuffleMoves --&gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">this</span>.moveInDirection (MOVE_DIRECTIONS[rand(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)]);
    }
    <span class="hljs-keyword">this</span>.shuffling = <span class="hljs-literal">false</span>;
  }

  isSolved () {
    <span class="hljs-keyword">for</span> (let i=<span class="hljs-number">0</span>; i&lt;NUM_TILES; i++) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.board[i][<span class="hljs-number">0</span>] !== GameState.solvedBoard[i][<span class="hljs-number">0</span>] 
          || <span class="hljs-keyword">this</span>.board[i][<span class="hljs-number">1</span>] !== GameState.solvedBoard[i][<span class="hljs-number">1</span>]) 
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
}</code></pre>
<p>Now, let&#39;s write a method to give us the current state of the game as a plain object for convenience.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameState</span> </span>{
  <span class="hljs-comment">// ...</span>

  getState () { 
    <span class="hljs-comment">// inside the object literal, `this` will refer to </span>
    <span class="hljs-comment">// the object we are making, not to the current GameState instance.</span>
    <span class="hljs-comment">// So, we will store the context of `this` in a constant called `self`</span>
    <span class="hljs-comment">// and use it.</span>
    <span class="hljs-comment">// Another way to do it is to use GameState.instance instead of self.</span>
    <span class="hljs-comment">// that will work, because GameState is a singleton class.</span>

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">self</span> = this;    

    <span class="hljs-keyword">return</span> {
      board: <span class="hljs-keyword">self</span>.board,
      moves: <span class="hljs-keyword">self</span>.moves,
      solved: <span class="hljs-keyword">self</span>.isSolved(),
    };
  }
}</code></pre>
<p>With this, the implementation of our <code>GameState</code> class is complete. We will use it in our custom react hook to power the react app for the game.</p>
<h3 id="the-usegamestate-custom-hook">The <code>useGameState</code> custom hook</h3>
<p>Now let&#39;s wrap the GameState functionalities in a custom React Hook, so that we can use it in our React application. In this hook, we want to register event handlers for keypress so that the users can play the puzzle using directional keys of their keyboards, generate click handler functions so that users can click tiles to move them, we also want to create helper functions to undo a move and start a new game.</p>
<p>We will attach the keyup event handlers to the document object. This needs to be done only once when the app is mounted and the event handlers need to be removed when the app is unmounted.</p>
<p>The primary purpose of this Hook is to wrap the GameState instance as a React state, that the React components can use and update. We will not, of course, expose the raw setState method to the components. Rather, we will expose functions like <code>newGame</code>, <code>undo</code> and <code>move</code> to the components so that they can trigger state updates when the user wants to start a new game or undo a move or move a specific tile. We will expose only that part of the state and update logic, which the components using the hook absolutely need. (Keyboard events will be handled by the listeners attached to the document object. The components need not have access to those event handlers.)</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useGameState</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// get the current GameState instance</span>
  <span class="hljs-keyword">const</span> gameState = GameState.getInstance();

  <span class="hljs-comment">// create a react state from the GameState instance</span>
  <span class="hljs-keyword">const</span> [state, setState] = React.useState(gameState.getState());

  <span class="hljs-comment">// start a new game and update the react state</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newGame</span> (<span class="hljs-params"></span>) </span>{
    gameState.startNewGame();
    setState(gameState.getState());
  }

  <span class="hljs-comment">// undo the latest move and update the react state</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">undo</span> (<span class="hljs-params"></span>) </span>{
    gameState.undo();
    setState(gameState.getState());
  }

  <span class="hljs-comment">// return a function that will move the i-th tile </span>
  <span class="hljs-comment">// and update the react state </span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span> (<span class="hljs-params">i</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      gameState.moveTile(i);
      setState(gameState.getState());
    }
  }

  React.useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// attach the keyboard event listeners to document</span>
    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'keyup'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listeners</span> (<span class="hljs-params">event</span>) </span>{

      <span class="hljs-keyword">if</span> (event.keyCode === <span class="hljs-number">37</span>) gameState.moveInDirection(<span class="hljs-string">'left'</span>);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.keyCode === <span class="hljs-number">38</span>) gameState.moveInDirection(<span class="hljs-string">'up'</span>);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.keyCode === <span class="hljs-number">39</span>) gameState.moveInDirection(<span class="hljs-string">'right'</span>);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.keyCode === <span class="hljs-number">40</span>) gameState.moveInDirection(<span class="hljs-string">'down'</span>);

      setState(gameState.getState());
    });

    <span class="hljs-comment">// remove the evant listeners when the app unmounts</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">(<span class="hljs-params"></span>) =&gt; <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-params">listeners</span>)</span>);
  }, [<span class="hljs-params">gameState</span>]); 
  // <span class="hljs-params">this</span> <span class="hljs-params">effect</span> <span class="hljs-params">hook</span> <span class="hljs-params">will</span> <span class="hljs-params">run</span> <span class="hljs-params">only</span> <span class="hljs-params">when</span> <span class="hljs-params">the</span> <span class="hljs-params">GameState</span> <span class="hljs-params">instance</span> <span class="hljs-params">changes</span>.
  // <span class="hljs-params">That</span> <span class="hljs-params">is</span>, <span class="hljs-params">only</span> <span class="hljs-params">when</span> <span class="hljs-params">the</span> <span class="hljs-params">app</span> <span class="hljs-params">is</span> <span class="hljs-params">mounted</span> <span class="hljs-params">and</span> <span class="hljs-params">the</span> <span class="hljs-params">GameState</span> <span class="hljs-params">instance</span>
  // <span class="hljs-params">is</span> <span class="hljs-params">created</span>

  // <span class="hljs-params">expose</span> <span class="hljs-params">the</span> <span class="hljs-params">state</span> <span class="hljs-params">and</span> <span class="hljs-params">the</span> <span class="hljs-params">update</span> <span class="hljs-params">functions</span> <span class="hljs-params">for</span> <span class="hljs-params">the</span> <span class="hljs-params">components</span> 
  <span class="hljs-params">return</span> [<span class="hljs-params">state</span>.<span class="hljs-params">board</span>, <span class="hljs-params">state</span>.<span class="hljs-params">moves</span>, <span class="hljs-params">state</span>.<span class="hljs-params">solved</span>, <span class="hljs-params">newGame</span>, <span class="hljs-params">undo</span>, <span class="hljs-params">move</span>];
}</span></code></pre>
<h3 id="the-react-components-of-the-puzzle">The React components of the Puzzle</h3>
<p>Now that we have a conceptual model of the puzzle and functions to update that model on user interaction events, let&#39;s write some components to display the game on screen. The game display here is pretty simple, it has a header part that shows the number of moves the user has made and the undo button. Below that is the puzzle board which will have the tiles. The puzzle board will also display a <code>PLAY AGAIN</code> button when the puzzle is solved.</p>
<p>In the puzzle board, we do not need to render the 16th tile, because that represents the empty tile. In the display, that will remain empty. On each of the displayed tiles, we will add an <code>onClick</code> event handler, so that when the user clicks on a tile, it will move if it can be moved.</p>
<p>The puzzle board will be of the dimensions <code>400px * 400px</code> and the tiles will be positioned absolutely with respect to it. Each tile will be of the dimension <code>95px * 95px</code> with <code>5px</code> gutter space between tiles.</p>
<p>The following function implements the <code>App</code> component. This is the basic layout of the application.    </p>
<pre><code class="language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [board, moves, solved, newGame, undo, move] = useGameState();

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'game-container'</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'game-header'</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'moves'</span>&gt;</span>
          {moves}
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'big-button'</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{undo}</span>&gt;</span> UNDO <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'board'</span>&gt;</span>
      {
        board.slice(0,-1).map((pos, index) =&gt; ( 
          <span class="hljs-tag">&lt;<span class="hljs-name">Tile</span> <span class="hljs-attr">index</span>=<span class="hljs-string">{index}</span> <span class="hljs-attr">pos</span>=<span class="hljs-string">{pos}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{move(index)}</span> /&gt;</span>
        ))
      }
      { solved &amp;&amp;
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'overlay'</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'big-button'</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{newGame}</span>&gt;</span>
              PLAY AGAIN 
            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      }
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  );
}

ReactDOM.render(<span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Now, let&#39;s implement the <code>Tile</code> component, which will display and position each individual tile on the board. As mentioned earlier, the tiles will be positioned absolutely with respect to the board. Given the <code>row index</code> and <code>column index</code> of a tile, we can find its position on the board. We know that each square on the grid is of the dimension <code>100px * 100px</code> with <code>5px</code> gutter space between tiles. So, we can simply multiply the <code>row index</code> and <code>column index</code> of the tile with 100 and add 5, to get the top and left positions of the tile.</p>
<p>Similarly, we can derive the backgroundPosition of the background image for each tile, by finding which part of the background image they display when placed in the correct order. For that first we need to calculate the position of the tile, when in placed correct order. We know that the <code>i-th</code> tile is positioned on <code>Math.floor(i / 4)</code>th row and <code>i % 4</code>th column in the correct order. From that we can calculate the position in form of pixels from top and pixels from left by multiplying the row and column indices by 100 and then adding 5. The background positions will be the negative of these values.</p>
<pre><code class="language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Tile</span> (<span class="hljs-params">{index, pos, onClick}</span>) </span>{
  <span class="hljs-keyword">const</span> top = pos[<span class="hljs-number">0</span>]*<span class="hljs-number">100</span> + <span class="hljs-number">5</span>;
  <span class="hljs-keyword">const</span> left = pos[<span class="hljs-number">1</span>]*<span class="hljs-number">100</span> + <span class="hljs-number">5</span>;
  <span class="hljs-keyword">const</span> bgLeft = (index%<span class="hljs-number">4</span>)*<span class="hljs-number">100</span> + <span class="hljs-number">5</span>;
  <span class="hljs-keyword">const</span> bgTop = <span class="hljs-built_in">Math</span>.floor(index/<span class="hljs-number">4</span>)*<span class="hljs-number">100</span> + <span class="hljs-number">5</span>;

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> 
    <span class="hljs-attr">className</span>=<span class="hljs-string">'tile'</span>
    <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onClick}</span>
    <span class="hljs-attr">style</span>=<span class="hljs-string">{{top,</span> <span class="hljs-attr">left</span>, <span class="hljs-attr">backgroundPosition:</span> `<span class="hljs-attr">-</span>${<span class="hljs-attr">bgLeft</span>}<span class="hljs-attr">px</span> <span class="hljs-attr">-</span>${<span class="hljs-attr">bgTop</span>}<span class="hljs-attr">px</span>`}} 
  /&gt;</span>;
}</span></code></pre>
<h3 id="styling-the-puzzle">Styling the Puzzle</h3>
<p>Before styling the puzzle, we need to find a good <code>400px * 400px</code> image to use as the background image of our tiles. Alternatively, we can also use numbers for the puzzle (like the wikipedia article for 15-Puzzle mentioned). In any case, let&#39;s look at some of the important bits of styling this app.</p>
<h4 id="positioning-the-board-and-the-tiles">Positioning the board and the tiles</h4>
<p>The actual width and height of the board will be <code>400px + 5px</code>, because 4 columns or rows need 5 gutters around them. However that does not affect the dimensions of the tiles, because we can safely think the 5th gutter to be outside the board. The board needs to have position declared as <code>relative</code> so that the tiles can be positioned absolutely with respect to it.</p>
<p>In case of the tiles, the dimension will be <code>95px * 95px</code> to allow for the <code>5px</code> gutters.  Their <code>background-size</code>, however, should be <code>400px * 400px</code>, because each tile shows only a specific square from the full sized <code>400px * 400px</code> image. The background position will be set as inline style by the react component. </p>
<p>To make the tile movements appear smooth and natural, we can use css transitions. Here we have used a 0.1s ease-in-out transition on tiles.  </p>
<pre><code class="language-css"><span class="hljs-selector-class">.board</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">405px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">405px</span>;
  <span class="hljs-attribute">position</span>: relative;
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#ddd</span>;
}

<span class="hljs-selector-class">.tile</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">95px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">95px</span>;
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">background</span>: white;
  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.1s</span> ease-in-out;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">2px</span>;
  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">'@{bg-img}'</span>);
  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">400px</span> <span class="hljs-number">400px</span>;
}</code></pre>
<h4 id="positioning-the-overlay">Positioning the overlay</h4>
<p>The overlay is another direct child of the board. It needs to cover the board when the game ends. So, we will give it the same dimensions as the board and place it absolutely at <code>(0, 0)</code>. It needs to be over the tiles, so we will give it a high <code>z-index</code>. We will also give it a semi transparent dark background color. It will contain the <code>PLAY AGAIN</code> button at the center, so we will make it a flex container with both <code>align-items</code> and <code>justify-content</code> set to <code>center</code>.</p>
<pre><code class="language-css"><span class="hljs-selector-class">.overlay</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">405px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">405px</span>;
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">z-index</span>: <span class="hljs-number">10</span>;
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#0004</span>;
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">align-items</span>: center;
  <span class="hljs-attribute">justify-content</span>: center;
}</code></pre>
<p><strong>Here is the pen containing everything described in this article.</strong></p>
<p><em>(Pardon me for embedding the image in base64 encoded form at the beginning of the less file. Adding asset files on codepen is a PRO only feature, and I, quite regrettably, is a free tier user.)</em> </p>
<p class="codepen" data-height="265" data-theme-id="0" data-default-tab="css,result" data-user="gnsp" data-slug-hash="YzKvWPj" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="15-Puzzle (Using React Hooks)">
  <span>See the Pen <a href="https://codepen.io/gnsp/pen/YzKvWPj">
  15-Puzzle (Using React Hooks)</a> by Ganesh Prasad (<a href="https://codepen.io/gnsp">@gnsp</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>

<p>Hoping you enjoyed reading about this little project and learned a few things from it. </p>
<p><strong>Thanks for reading !</strong></p>
</article></main><aside><h4></h4><ul><li><h5>November 17, 2017</h5><h2><a href="https://gnsp.in/blog/posts/classnames-vs-es6-template-literals-b3B78q/index.html">classnames vs  ES6 template literals</a></h2><ul class="tags"><li><a href="https://gnsp.in/blog/categories/web.html">web</a></li><li><a href="https://gnsp.in/blog/categories/css.html">css</a></li><li><a href="https://gnsp.in/blog/categories/javascript.html">javascript</a></li><li><a href="https://gnsp.in/blog/categories/react.html">react</a></li></ul><p>A rather funny incident happened with me today, which got me into thinking analytically about the advantages and/or<br/>disadvantages of using the classnames library with restpect to ES6 template literals while crea<span class="ellipsis">...</span></p></li><li><h5>September 7, 2019</h5><h2><a href="https://gnsp.in/blog/posts/making-a-neon-clock-using-react-hooks-XNgI3Z/index.html">Making a Neon Clock using React Hooks</a></h2><ul class="tags"><li><a href="https://gnsp.in/blog/categories/react.html">react</a></li><li><a href="https://gnsp.in/blog/categories/javascript.html">javascript</a></li><li><a href="https://gnsp.in/blog/categories/css.html">css</a></li><li><a href="https://gnsp.in/blog/categories/html.html">html</a></li><li><a href="https://gnsp.in/blog/categories/pug.html">pug</a></li><li><a href="https://gnsp.in/blog/categories/less.html">less</a></li></ul><p><br/>A little bit of backstory<br/>TL;DR; some rather dark humour on what motivated me to make the clock<br/><br/><span class="ellipsis">...</span></p></li><li><h5>September 30, 2019</h5><h2><a href="https://gnsp.in/blog/posts/opensourcing-classd-TbZb2U/index.html">Opensourcing classd</a></h2><ul class="tags"><li><a href="https://gnsp.in/blog/categories/react.html">react</a></li><li><a href="https://gnsp.in/blog/categories/javascript.html">javascript</a></li><li><a href="https://gnsp.in/blog/categories/web.html">web</a></li><li><a href="https://gnsp.in/blog/categories/opensource.html">opensource</a></li><li><a href="https://gnsp.in/blog/categories/technology.html">technology</a></li><li><a href="https://gnsp.in/blog/categories/css.html">css</a></li></ul><p><br/>If you are a frontend developer, there is a fair chance that you have used<br/>Jedwatson&#39;s classNames package in your projects. In fact, classNames is the official replace<span class="ellipsis">...</span></p></li><li><h5>August 31, 2019</h5><h2><a href="https://gnsp.in/blog/posts/making-the-flag-of-india-using-pug-and-less-cLjONG/index.html">Making the flag of India using Pug and Less</a></h2><ul class="tags"><li><a href="https://gnsp.in/blog/categories/html.html">html</a></li><li><a href="https://gnsp.in/blog/categories/css.html">css</a></li><li><a href="https://gnsp.in/blog/categories/pug.html">pug</a></li><li><a href="https://gnsp.in/blog/categories/less.html">less</a></li></ul><p>In this article we shall make the national flag of India (the tricolour). As an aside and fun fact, a number of other countries have national flags featuring 3 colours and the Indian flag actually has 4 colours.<br/><span class="ellipsis">...</span></p></li><li><h5>July 17, 2017</h5><h2><a href="https://gnsp.in/blog/posts/software-development-at-zomato-kKa08C/index.html">Software Development At Zomato</a></h2><ul class="tags"><li><a href="https://gnsp.in/blog/categories/programming.html">programming</a></li></ul><p>It has been almost 2 months since I first found myself employed and working fulltime on something I liked and cared
about; in short I have been coding for last 2 months with a bunch of awesome people who like coding new stuff on a rather
daily basis.<span class="ellipsis">...</span></p></li><li><h5>December 26, 2015</h5><h2><a href="https://gnsp.in/blog/posts/a-tutorial-on-dynamic-programming-dp-GcvQKX/index.html">A Tutorial on Dynamic Programming (DP)</a></h2><ul class="tags"><li><a href="https://gnsp.in/blog/categories/programming.html">programming</a></li><li><a href="https://gnsp.in/blog/categories/algorithms.html">algorithms</a></li><li><a href="https://gnsp.in/blog/categories/logic.html">logic</a></li><li><a href="https://gnsp.in/blog/categories/cpp.html">cpp</a></li></ul><p>
Now that a number of people have asked me for some good resources on DP and I could find only a few good 
resources to give the beginners a real boost, I decided to write this basic DP tutorial here. But before we go 
deep into it, I want to make it<span class="ellipsis">...</span></p></li></ul></aside><div class="footer"><h6>Powered by <a href='https://npmjs.com/package/ghournal'>ghournal</a></h6></div><script async src="https://static.codepen.io/assets/embed/ei.js"></script></body></html>
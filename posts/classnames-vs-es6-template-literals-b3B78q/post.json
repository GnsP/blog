{
    "filepath": "./posts/classnames-vs-es6-template-literals-b3B78q/post.json",
    "id": "classnames-vs-es6-template-literals-b3B78q",
    "title": "classnames vs  ES6 template literals",
    "href": "https://gnsp.in/blog/posts/classnames-vs-es6-template-literals-b3B78q/index.html",
    "cover_image": false,
    "created": "November 17, 2017",
    "modified": "November 17, 2017",
    "published": true,
    "categories": [
        "web",
        "css",
        "javascript",
        "react"
    ],
    "content": "<p>A rather funny incident happened with me today, which got me into thinking analytically about the advantages and/or\ndisadvantages of using the <strong>classnames</strong> library with restpect to <strong>ES6 template literals</strong> while creating React\nComponents with stateful styling. Today one of my friends (co-developer in a React project, to be precise) claimed\nthat <em>classnames is always a better option than ES6 template literals when dealing with styling of React components</em>,\nand they even went on to bet â‚¹1000 on this claim (<em>The claim derives it&#39;s confidence from the notion that classnames,\nbeing a popular and widely used library, must be the better option.</em>). I had to maintain my habit of <em>not betting</em>,\nhowever I got the idea to actually analyse the claim.</p>\n<p>In simpler words, my friend claimed that <strong>Approach A</strong> is better than <strong>Approach B</strong> given below.</p>\n<h4 id=\"approach-a\">Approach A</h4>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">React</span>, { <span class=\"hljs-type\">Component</span> } from <span class=\"hljs-symbol\">'reac</span>t';\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">PropTypes</span> from <span class=\"hljs-symbol\">'prop</span>-types';\n<span class=\"hljs-keyword\">import</span> classnames from <span class=\"hljs-symbol\">'classname</span>s';\n\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ExampleComponent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n  static propTypes = {\n    variant: <span class=\"hljs-type\">PropTypes</span>.oneOf ([ <span class=\"hljs-symbol\">'inf</span>o', <span class=\"hljs-symbol\">'succes</span>s', <span class=\"hljs-symbol\">'warnin</span>g', <span class=\"hljs-symbol\">'erro</span>r' ]).isRequired,\n    className: <span class=\"hljs-type\">PropTypes</span>.string\n  };\n\n  static defaultProps = {\n    className: ''\n  };\n\n  render () {\n    <span class=\"hljs-keyword\">return</span> (\n      &lt;div\n        className={ classnames (\n          <span class=\"hljs-symbol\">'my</span>-custom-<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>',</span>\n          <span class=\"hljs-keyword\">this</span>.props.className,\n          {\n            <span class=\"hljs-symbol\">'info</span>-<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>'</span>: <span class=\"hljs-keyword\">this</span>.props.variant === <span class=\"hljs-symbol\">'inf</span>o',\n            <span class=\"hljs-symbol\">'success</span>-<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>'</span>: <span class=\"hljs-keyword\">this</span>.props.variant === <span class=\"hljs-symbol\">'succes</span>s',\n            <span class=\"hljs-symbol\">'warning</span>-<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>'</span>: <span class=\"hljs-keyword\">this</span>.props.variant === <span class=\"hljs-symbol\">'warnin</span>g',\n            <span class=\"hljs-symbol\">'error</span>-<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>'</span>: <span class=\"hljs-keyword\">this</span>.props.variant === <span class=\"hljs-symbol\">'erro</span>r',\n          }\n        ) }\n      /&gt;\n    );\n  }\n}</code></pre>\n<h4 id=\"approach-b\">Approach B</h4>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">React</span>, { <span class=\"hljs-type\">Component</span> } from <span class=\"hljs-symbol\">'reac</span>t';\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">PropTypes</span> from <span class=\"hljs-symbol\">'prop</span>-types';\n\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ExampleComponent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n  static propTypes = {\n    variant: <span class=\"hljs-type\">PropTypes</span>.oneOf ([ <span class=\"hljs-symbol\">'inf</span>o', <span class=\"hljs-symbol\">'succes</span>s', <span class=\"hljs-symbol\">'warnin</span>g', <span class=\"hljs-symbol\">'erro</span>r' ]).isRequired,\n    className: <span class=\"hljs-type\">PropTypes</span>.string\n  };\n\n  static defaultProps = {\n    className: ''\n  };\n\n  static const classnamesRegistry = {\n    info: <span class=\"hljs-symbol\">'info</span>-<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>',</span>\n    success: <span class=\"hljs-symbol\">'success</span>-<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>',</span>\n    warning: <span class=\"hljs-symbol\">'warning</span>-<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>',</span>\n    error: <span class=\"hljs-symbol\">'error</span>-<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>'</span>\n  };\n\n  render () {\n    <span class=\"hljs-keyword\">return</span> (\n      &lt;div\n        className={`\n          my-custom-<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span>\n          ${ <span class=\"hljs-keyword\">this</span>.props.className }\n          ${ <span class=\"hljs-type\">ExampleComponent</span>.classnamesRegistry [<span class=\"hljs-keyword\">this</span>.props.variant] }\n        `}\n      /&gt;\n    );\n  }\n}</code></pre>\n<p>We will start with comparing rather obvious facts about both options and then compare them based on usage.</p>\n<h3 id=\"factual-comparisons\">Factual comparisons</h3>\n<table>\n<thead>\n<tr>\n<th>Point of comparison</th>\n<th>classnames</th>\n<th>ES6 template literals</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Category</strong></td>\n<td>Library, mantained by <a href=\"https://www.npmjs.com/~jedwatson\"><strong>@jedwatson</strong></a> and community.</td>\n<td>Language syntax, described in ES6 Sepcifications. Supported by Babel, tsc, coffeescript2.</td>\n</tr>\n<tr>\n<td><strong>Usability</strong></td>\n<td>Can be used in ES5, ES6, typescript, coffeescript...</td>\n<td>Is a syntactic feature of ES6 and typescript, coffeescript2 has a slightly different syntax. Can be transpiled to ES5.</td>\n</tr>\n<tr>\n<td><strong>Popularity</strong></td>\n<td>4,051,109 downloads in the last month on npm.</td>\n<td>Only babel-plugin-transform-es2015-template-literals has 7,043,250 downloads in the last month on npm.</td>\n</tr>\n<tr>\n<td><strong>Support</strong></td>\n<td>Published 2 years ago. 22 releases in total. Current version 2.2.5.</td>\n<td>babel-plugin-transform-es2015-template-literal was published 10 months ago. 34 releases in total. Current version 6.22.0.</td>\n</tr>\n</tbody></table>\n<h3 id=\"usage-comparisons\">Usage comparisons</h3>\n<p>In this section I will try to map every <strong>classnames</strong> feature documented in the README file of the library to equivalent\nES6 template literal syntax.</p>\n<pre><code class=\"language-javascript\">classnames (<span class=\"hljs-string\">'foo'</span>, <span class=\"hljs-string\">'bar'</span>);\n`foo bar`\n// outputs <span class=\"hljs-string\">'foo bar'</span>\n\nclassnames (<span class=\"hljs-string\">'foo'</span>, { <span class=\"hljs-string\">'bar'</span>: condition });\n`foo ${ condition &amp;&amp;  <span class=\"hljs-string\">'bar'</span> }`\n// outputs <span class=\"hljs-string\">'foo bar'</span> <span class=\"hljs-keyword\">when</span> condition == <span class=\"hljs-literal\">true</span>\n// outputs <span class=\"hljs-string\">'foo'</span> <span class=\"hljs-keyword\">when</span> condition == <span class=\"hljs-literal\">false</span>\n\nclassnames ({ <span class=\"hljs-string\">'foo'</span>: condA, <span class=\"hljs-string\">'bar'</span>: condB });\n`${ condA &amp;&amp; foo } ${ condB &amp;&amp; bar }`</code></pre>\n<p>There are two other versions of the classnames library, shipped with the library itself. <strong>classnames/dedupe</strong> and\n<strong>classnames/bind</strong>.</p>\n<p><strong>classnames/dedupe</strong> correctly dedupes classes and ensures that falsy classes specified in later\narguments are excluded from the result set. <em>But it&#39;s 5x slower than classnames and hence offered as an opt-in by\nclassnames.</em></p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">import</span> classnames <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'classnames/dedupe'</span>;\n\nclassnames (<span class=\"hljs-string\">'foo'</span>, <span class=\"hljs-string\">'foo'</span>, <span class=\"hljs-string\">'bar'</span>);\n<span class=\"hljs-comment\">// outputs 'foo bar'</span></code></pre>\n<p>The deduping of classes can be achieved in ES6 using <strong>tagged template literals</strong>. Simply create a function called\ndedupe and use it as a tag.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// dedupe.js</span>\n\n<span class=\"hljs-keyword\">const</span> dedupe = <span class=\"hljs-function\">(<span class=\"hljs-params\">strings, ...values</span>) =&gt;</span>\n  [...new Set (\n    strings.map ( <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span>, index</span>) =&gt;</span>\n      values [index] ? <span class=\"hljs-string\">`<span class=\"hljs-subst\">${ string }</span><span class=\"hljs-subst\">${ values[index] }</span>`</span> : <span class=\"hljs-built_in\">string</span>\n    ).join(<span class=\"hljs-string\">''</span>).split(<span class=\"hljs-regexp\">/\\s/</span>)\n  )].join(<span class=\"hljs-string\">' '</span>);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> dedupe;</code></pre>\n<p>Now we can import <code>dedupe</code> and use it as a tag, as shown in the following code.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">import</span> dedupe <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'dedupe'</span>;\n\ndedupe`foo foo bar`\n<span class=\"hljs-comment\">// outputs 'foo bar'</span></code></pre>\n<p><strong>classnames/bind</strong></p>\n<p>I am skipping this comparison, because the classnames/bind <a href=\"https://www.npmjs.com/package/classnames#dynamic-class-names-with-es2015\">documentation</a> says the following,</p>\n<p><em>Note that in ES2015 environments, it may be better to use the &quot;dynamic class names&quot; approach documented above.</em></p>\n<h3 id=\"few-observations\">Few observations</h3>\n<ol>\n<li>Using <strong>ES6 template literals</strong> and tagged template literals to manipulate classnames results in <strong>smaller bundle\nsize</strong>.</li>\n<li><strong>classnames</strong> is <strong>easy to use</strong>. It also makes it difficult for the programmer to shoot themselves in the foot.\nES6 template literals require the programmers to move out of their comfortzones and think more functionally.</li>\n<li><strong>ES6 template literals perform better</strong> because they get compiled to string concatenations.</li>\n</ol>\n<h3 id=\"conclusive-remarks\">Conclusive remarks</h3>\n<p>Choosing between <strong>Approach A</strong> and <strong>Approach B</strong>, more or less, depends on the whether we want to trade performance\nsmaller bundle size for ease-of-use. Also, believing in something solely because a lot of people believe in it or because\na lot of people do it, is a bad idea. <strong>Never believe in any claims without proper analysis.</strong> Peace.</p>\n",
    "abstract": "A rather funny incident happened with me today, which got me into thinking analytically about the advantages and/or<br/>disadvantages of using the classnames library with restpect to ES6 template literals while crea<span class=\"ellipsis\">...</span>",
    "date": "November 17, 2017"
}
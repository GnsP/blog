{
    "filepath": "./posts/a-tutorial-on-dynamic-programming-dp-GcvQKX/post.json",
    "href": "https://gnsp.in/blog/posts/a-tutorial-on-dynamic-programming-dp-GcvQKX/index.html",
    "created": "December 26, 2015",
    "modified": "26th December, 2015",
    "published": true,
    "categories": [
        "programming",
        "algorithms",
        "logic",
        "cpp"
    ],
    "content": "<hr>\n<p>Now that a number of people have asked me for some good resources on DP and I could find only a few good \nresources to give the beginners a real boost, I decided to write this basic DP tutorial here. But before we go \ndeep into it, I want to make it clear that the only way to master DP is a lot of practice. The more you solve, \nthe better you get. </p>\n<p>DP is an ART. It’s a way of thinking. It’s more like learning to see the same thing from a different perspective. \nIt takes some time to get used to, that’s why practicing without getting disheartened is the key to mastering DP.</p>\n<p>Prerequisites for this tutorial are, the knowledge of </p>\n<ol>\n<li>iteration over (multidimensional) arrays, </li>\n<li>recursion, </li>\n<li>basic knowledge of mathematical notations.</li>\n</ol>\n<p><strong>An important tip</strong></p>\n<p>When you are given a problem to solve using DP, the trick is “Not to over-think, because the solution is always hidden \nin the problem”. Most beginners make this mistake of thinking too much, only because they thought the problem was difficult \nand only a complex solution would solve it. But in most cases the solution turns out to be simple.</p>\n<p>Before you start coding, formulate the problem (not the solution) mathematically on a piece of paper. \nBecause a problem well formulated is a problem half solved.</p>\n<p>For example, let’s consider a simple problem. </p>\n<h3 id=\"the-problem\">THE PROBLEM</h3>\n<p>I am to count from 1 to N. But I follow a special rule of counting, I can count either <code>2*x</code> or <code>3*x</code> or <code>x+1</code> after \nI count <code>x</code>. I always start counting from 1. Now what is the minimum number of steps required to count to <code>N</code>.</p>\n<p>Here is the example of this counting : If I want to count till 7, I can count like the following:</p>\n<pre><code><span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">7</span>\nor <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">7</span>\nor <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">7</span>\nor <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">7</span>\nor <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">7</span></code></pre><p>In this case the minimum number of steps is 4.</p>\n<h3 id=\"analysis\">ANALYSIS</h3>\n<p>Now let’s analyze this problem. Here we are asked to choose which number to count after <code>x</code>, such that we will reach <code>N</code> \nin minimum number of steps. Notice that, we are presented with a choice at a point and we have to make the choice in such \na way that our current choice combined with our subsequent choices will give us the optimal result.</p>\n<p>You might be tempted to think that the fastest way to reach <code>N</code> would be to count <code>x*3</code> after <code>x</code> whenever possible. \nIf <code>x*3 &gt; N</code>, then try to count <code>x*2</code> and if <code>x*2 &gt; N</code>, then count <code>x+1</code>. That’s the greedy way to solve this problem. \nAnd this greedy algorithm does not always work. For example if I am to count till 8, the greedy way will be to count \nlike <code>1 3 6 7 8</code> (5 steps). But the optimal way would be <code>1 2 4 8</code> (4 steps). Another example, count till 13 :<br>greedy way <code>1 3 9 10 11 12 13</code> (7 steps), optimal way <code>1 3 6 12 13</code> (5 steps).</p>\n<p>Now that we have established greedy algorithm won’t work here, let’s analyze why it does not work. It does not work, \nbecause we when we assumed that counting <code>x*3</code> and <code>x*2</code> and <code>x+1</code> in the preferential order will solve the problem, we did\nnot consider the effect of making a greedy choice on our subsequent choices.</p>\n<p>Before we solve this problem, let&#39;s formulate the problem statement mathematically.</p>\n<pre><code>Let f(<span class=\"hljs-keyword\">x</span>) = minimum number of steps required <span class=\"hljs-keyword\">to</span> count <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">x</span>.\n\nf(<span class=\"hljs-keyword\">x</span>) = <span class=\"hljs-number\">1</span>                                        when <span class=\"hljs-keyword\">x</span> = <span class=\"hljs-number\">1</span>\nf(<span class=\"hljs-keyword\">x</span>) = <span class=\"hljs-keyword\">min</span>( f(<span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">-1</span>) , f(<span class=\"hljs-keyword\">x</span>/<span class=\"hljs-number\">2</span>) , f(<span class=\"hljs-keyword\">x</span>/<span class=\"hljs-number\">3</span>) ) + <span class=\"hljs-number\">1</span>      when <span class=\"hljs-keyword\">x</span> &gt; <span class=\"hljs-number\">1</span></code></pre><p>It means, if we have already counted till <code>x-1</code> or <code>x/2</code> or <code>x/3</code>, then we can reach <code>x</code> in just one step. We just have to \nfind out whether it&#39;s faster to reach <code>x-1</code> or <code>x/2</code> or <code>x/3</code>. If <code>x-1</code> is faster to reach than <code>x/2</code> and <code>x/3</code>, then \ncounting to <code>x-1</code> and the counting <code>x</code> will definitely take less steps than counting to <code>x/2</code> then <code>x</code>, or counting to <code>x/3</code> then <code>x</code>.</p>\n<p>if <code>x%2 != 0</code>, we do not consider <code>f(x/2)</code> in the above expression, if <code>x%3 != 0</code> then we do not consider <code>f(x/3)</code> in the above \nexpression. Because if <code>x%2 != 0</code>, then <code>x/2</code> would not be an integer and <code>f(x)</code> is defined only for integers. Same for <code>f(x/3)</code>.</p>\n<h3 id=\"solution\">SOLUTION</h3>\n<p>As we can see, the function <code>f</code> is a recursive function. So, we can simply implement it as a recursive function in our language \nof choice and it should work correctly. But pure recursion will be slow when N is large. </p>\n<p>Let’s see, why pure recursion would be slow. Suppose I want to find <code>f(7)</code>.</p>\n<pre><code>f(<span class=\"hljs-number\">7</span>) = f(<span class=\"hljs-number\">6</span>) + <span class=\"hljs-number\">1</span>    [as <span class=\"hljs-number\">7</span>/<span class=\"hljs-number\">2</span> and <span class=\"hljs-number\">7</span>/<span class=\"hljs-number\">3</span> are not integers]\nf(<span class=\"hljs-number\">6</span>) = min ( f(<span class=\"hljs-number\">5</span>), f(<span class=\"hljs-number\">3</span>), f(<span class=\"hljs-number\">2</span>) ) + <span class=\"hljs-number\">1</span>\nf(<span class=\"hljs-number\">5</span>) = f(<span class=\"hljs-number\">4</span>) + <span class=\"hljs-number\">1</span>\nf(<span class=\"hljs-number\">4</span>) = min ( f(<span class=\"hljs-number\">3</span>) , f(<span class=\"hljs-number\">2</span>) ) + <span class=\"hljs-number\">1</span>\nf(<span class=\"hljs-number\">3</span>) = min( f(<span class=\"hljs-number\">2</span>), f(<span class=\"hljs-number\">1</span>) ) + <span class=\"hljs-number\">1</span>\nf(<span class=\"hljs-number\">2</span>) = f(<span class=\"hljs-number\">1</span>) + <span class=\"hljs-number\">1</span>\nf(<span class=\"hljs-number\">1</span>) = <span class=\"hljs-number\">1</span></code></pre><p>As we can see, in pure recursion, we will have to calculate <code>f(3)</code> and <code>f(2)</code> more than once. First during <code>f(6)</code> we call <code>f(5)</code> \nand it calls <code>f(4)</code> which calls <code>f(3)</code> and <code>f(2)</code>. When <code>f(4)</code> and <code>f(5)</code> have returned and we are back in the function call for \n<code>f(6)</code>, we call <code>f(3)</code> and <code>f(2)</code> again. Computing same values more than once makes pure recursive solution slower than it needs to be.</p>\n<p>But what if we calculate the values of <code>f(x)</code> when needed for the first time and store it in an array and the next time it’s \nneeded we simply look up the array and return the value without really calculating it all over again ? That would be a much \nfaster way to calculate <code>f(N)</code>. And this way is known as memoization or top-down DP.</p>\n<p>Here is the above idea implemented in C++ like pseudo code:</p>\n<pre><code class=\"language-cpp\"><span class=\"hljs-built_in\">int</span> memory[N+<span class=\"hljs-number\">1</span>];    // global <span class=\"hljs-built_in\">array</span>, all values initialized to <span class=\"hljs-number\">0</span>\nmemory[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">1</span>;      // because f(<span class=\"hljs-number\">1</span>) = <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-built_in\">int</span> f (<span class=\"hljs-built_in\">int</span> x) {\n     /* <span class=\"hljs-keyword\">if</span> f(x) <span class=\"hljs-keyword\">is</span> calculated <span class=\"hljs-keyword\">and</span> stored <span class=\"hljs-keyword\">in</span> memory, i.e the value <span class=\"hljs-keyword\">in</span> memory[x]\n        <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> the default value <span class=\"hljs-number\">0</span>, then just <span class=\"hljs-keyword\">return</span> it <span class=\"hljs-keyword\">without</span> calculation */\n      <span class=\"hljs-keyword\">if</span> ( memory[x] != <span class=\"hljs-number\">0</span> ) <span class=\"hljs-keyword\">return</span> memory[x];\n\n      /* otherwise calculate it recursively */\n      <span class=\"hljs-built_in\">int</span> <span class=\"hljs-literal\">result</span> = <span class=\"hljs-type\">INFINITY</span>;\n      <span class=\"hljs-keyword\">if</span> (x%<span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) <span class=\"hljs-literal\">result</span> = min (<span class=\"hljs-literal\">result</span>, f(x/<span class=\"hljs-number\">2</span>)); \n      <span class=\"hljs-keyword\">if</span> (x%<span class=\"hljs-number\">3</span> == <span class=\"hljs-number\">0</span>) <span class=\"hljs-literal\">result</span> = min (<span class=\"hljs-literal\">result</span>, f(x/<span class=\"hljs-number\">3</span>));\n      <span class=\"hljs-literal\">result</span> = min (<span class=\"hljs-literal\">result</span>, f(x-<span class=\"hljs-number\">1</span>) );\n      <span class=\"hljs-literal\">result</span> = <span class=\"hljs-literal\">result</span> + <span class=\"hljs-number\">1</span>;\n\n      /* now store the <span class=\"hljs-literal\">result</span> <span class=\"hljs-keyword\">in</span> the <span class=\"hljs-built_in\">array</span> <span class=\"hljs-keyword\">for</span> future use <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">return</span> */\n      memory[x] = <span class=\"hljs-literal\">result</span>;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">result</span>;\n}</code></pre>\n<p>Makes sense ? If not, pause a bit here and read the pseudo code above. Try to imagine how it works during subsequent calls. </p>\n<p>Just being able to solve a problem using top-down DP or memoization is enough in most of the cases. But, when the dataset if \ntoo large, the number of recursive calls might result in a function call stack overflow. Normally reported as a case of <code>SIGSSEV</code>, \nmore commonly known as <code>segmentation fault</code>.  Hence it’s important to learn how to solve the DP problems without recursion.  </p>\n<p>Before we convert our recursive solution into an iterative one, let&#39;s make a few observations about the function <code>f</code>.</p>\n<ol>\n<li>value of <code>f(x)</code> can never exceed <code>x</code>, i.e. <code>f(x) &lt;= x</code></li>\n<li>if we know <code>f(x) &lt;= y</code>, we can say <code>f(x+1) &lt;= y+1</code>, <code>f(x*2) &lt;= y+1</code> and <code>f(x*3) &lt;= y+1</code></li>\n<li>value of <code>f(x)</code> can not be determined with certainty untill values of <code>f(x/3)</code>, <code>f(x/2)</code> and <code>f(x-1)</code> have been determined.</li>\n<li>initially only <code>f(1) = 1</code> is determined.</li>\n</ol>\n<p>Let&#39;s use these observations to write an iterative solution (in C++ like pseudo code)</p>\n<pre><code class=\"language-cpp\">int f[N+<span class=\"hljs-number\">1</span>]<span class=\"hljs-comment\">;    // initalize an array to store values of f(1), f(2) ... f(N)\n</span>\nvoid iterativeDP () {\n    for (int <span class=\"hljs-keyword\">x</span>=<span class=\"hljs-number\">1</span><span class=\"hljs-comment\">; x&lt;=N; x++) f[x] = x;      // Initially assume that f(x) = x\n</span>\n    // when we have determined f(<span class=\"hljs-keyword\">x</span>) update values of f(<span class=\"hljs-keyword\">x</span>+<span class=\"hljs-number\">1</span>), f(<span class=\"hljs-keyword\">x</span>*<span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">and</span> f(<span class=\"hljs-keyword\">x</span>*<span class=\"hljs-number\">3</span>)\n    for (int <span class=\"hljs-keyword\">x</span>=<span class=\"hljs-number\">1</span><span class=\"hljs-comment\">; x&lt;=N; x++) {\n</span>        if (<span class=\"hljs-keyword\">x</span>+<span class=\"hljs-number\">1</span> &lt;= N) f[<span class=\"hljs-keyword\">x</span>+<span class=\"hljs-number\">1</span>] = <span class=\"hljs-keyword\">min</span> (f[<span class=\"hljs-keyword\">x</span>+<span class=\"hljs-number\">1</span>], f[<span class=\"hljs-keyword\">x</span>]+<span class=\"hljs-number\">1</span>)<span class=\"hljs-comment\">;\n</span>        if (<span class=\"hljs-keyword\">x</span>*<span class=\"hljs-number\">2</span> &lt;= N) f[<span class=\"hljs-keyword\">x</span>*<span class=\"hljs-number\">2</span>] = <span class=\"hljs-keyword\">min</span> (f[<span class=\"hljs-keyword\">x</span>*<span class=\"hljs-number\">2</span>], f[<span class=\"hljs-keyword\">x</span>]+<span class=\"hljs-number\">1</span>)<span class=\"hljs-comment\">;\n</span>        if (<span class=\"hljs-keyword\">x</span>*<span class=\"hljs-number\">3</span> &lt;= N) f[<span class=\"hljs-keyword\">x</span>*<span class=\"hljs-number\">3</span>] = <span class=\"hljs-keyword\">min</span> (f[<span class=\"hljs-keyword\">x</span>*<span class=\"hljs-number\">3</span>], f[<span class=\"hljs-keyword\">x</span>]+<span class=\"hljs-number\">1</span>)<span class=\"hljs-comment\">;\n</span>    }\n}</code></pre>\n<p>So, that&#39;s that and we just solved the problem using DP in both top-down (recursive) and bottom-up (iterative) methods.</p>\n",
    "title": "A Tutorial on Dynamic Programming (DP)",
    "date": "December 26, 2015",
    "abstract": "\nNow that a number of people have asked me for some good resources on DP and I could find only a few good \nresources to give the beginners a real boost, I decided to write this basic DP tutorial here. But before we go \ndeep into it, I want to make it<span class=\"ellipsis\">...</span>",
    "cover_image": false,
    "id": "a-tutorial-on-dynamic-programming-dp-GcvQKX"
}
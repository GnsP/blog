{
    "filepath": "./posts/hackerrank-dp-play-game/post.json",
    "title": "An Easy Dynamic Programming Problem and Solution Analysis",
    "abstract": "Analysing how I approached and solved a dynamic programming problem. [Easy]",
    "created": "1st September, 2017",
    "modified": "1st September, 2017",
    "published": true,
    "categories": [
        "Coding"
    ],
    "content": "<p>After about one year abstinence from competitive coding, I was busy with Ironscript and the job lately,\nI found some time to do some fun stuff yesterday (apparently I got ill with Hepatitis-E and was advised to rest, resting\nturned out to be boring). So I decided to solve a problem on Dynamic Programming from <a href=\"https://hackerrank.com\">HackerRank</a>.\nThe problem goes like the following.</p>\n\n<h4>Problem Statement</h4>\n\n<p>You and your friend decide to play a game using a stack consisting of <code>N</code> bricks.\nIn this game, you can alternatively remove 1, 2 or 3 bricks from the top, and the numbers\netched on the removed bricks are added to your score. You have to play so that you obtain\nthe maximum possible score. <em>It is given that your friend will also play optimally and you make the first move.</em></p>\n\n<p><code>N</code> is of the order of 100,000 and the output should be a single integer which is the maximum score\nobtainale by you.</p>\n\n<h4>So how do I solve it ?</h4>\n\n<p>Here the input is a sequence <code>seq[0:N]</code> of integers of length <code>N</code>. From this sequence the player is allowed to take\n1 or 2 or 3 values at a time. Let <code>f(seq)</code> be the function that returns the maximum obtainable score by the player who\ntakes the first move for any sequence.</p>\n\n<p>If the player who moves first takes a few (1 or 2 or 3) values from the sequence then he/she gets the sum of those values\nplus the maximum obtainable score after the opponent makes his optimal move; i.e. on the next move the opponent gets the\nmaximum obtainable score of the rest of the sequence and our player gets what&#39;s left.</p>\n\n<p>Mathematically, we can express it as:</p>\n\n<p><code>\n  f (seq) = max (\n              seq[0] + sum( seq[1:N] ) - f( seq[1:N] ) ,\n              seq[0] + seq[1] + sum( seq[2:N] ) - f( seq[2:N] ) ,\n              seq[0] + seq[1] + seq[2] + sum( seq[3:N] ) - f( seq[3:N] )\n            )\n</code></p>\n\n<p>i.e. the player should choose to pick 1 or 2 or 3 values depending on which move maximizes his score for the rest of\nthe game.</p>\n\n<p>In a traditional dynamic programming solution, we can model this function using 2 arrays of length <code>N</code> each, one array\nto memorize the <code>sum</code> (because sum of a sequence can be described recursively as sum of a value and the subsequence\nwithout that value) function and another array to memorize the function <code>f</code>. But if we observe closely, we can see that\nour solution depends on the 3 consecutive values of <code>sum</code> and <code>f</code> at a time. Therefore we can reduce the arrays of length\n<code>N</code> to arrays of length <code>4</code> (the current value and the 3 consecutive dependent values) and save a lot of memory.</p>\n\n<p><strong>The following is a C++ program implementing the solution described.</strong></p>\n\n<p><code></code>`</p>\n\n<h1>include &lt;iostream&gt;</h1>\n\n<h1>include &lt;vector&gt;</h1>\n\n<p>using namespace std;</p>\n\n<p>unsigned long long max (unsigned long long a, unsigned long long b, unsigned long long c) {</p>\n\n<p>  if (a &gt; b &amp;&amp; a &gt; c) return a;\n  if (b &gt; c) return b;\n  return c;\n}</p>\n\n<p>int main () {\n  int T, N;\n  unsigned long long sum[4], dp[4];\n  cin &gt;&gt; T;\n  while (T--) {\n    cin &gt;&gt; N;\n    vector &lt;int&gt; bricks (N+3, 0);\n    for (int i=0; i&lt;N; i++) cin &gt;&gt; bricks[i];</p>\n\n<pre><code>for (int i=0; i&lt;4; i++) {\n  sum[i] = 0;\n  dp[i] = 0;\n}\n\nfor (int i=N-1; i&gt;=0; i--) {\n  sum[i % 4] = sum[(i+1) % 4] + bricks[i];\n  dp[i % 4] = max (\n    bricks[i] + sum[(i+1) % 4] - dp[(i+1) % 4],\n    bricks[i] + bricks[i+1] + sum[(i+2) % 4] - dp[(i+2) % 4],\n    bricks[i] + bricks[i+1] + bricks[i+2] + sum[(i+3) % 4] - dp[(i+3) % 4]\n  );\n}\ncout &lt;&lt; dp[0] &lt;&lt; endl;</code></pre>\n\n<p>  }\n  return 0;\n}\n<code></code>`</p>"
}
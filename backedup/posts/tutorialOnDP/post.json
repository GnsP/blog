{
    "filepath": "./posts/tutorialOnDP/post.json",
    "title": "A Tutorial On Dynamic Programming (Top Down Approach)",
    "abstract": "Dynamic Programming (DP) is an algorithmic technique generally used in solving optimization problems. Dynamic Programming is an important and quite difficult technique to master, but it's highly useful as DP can reduce problems of exponential brute-force time complexity to polynomial complexity.",
    "created": "27th April, 2016",
    "modified": "27th April, 2016",
    "published": true,
    "categories": [
        "Coding"
    ],
    "content": "<p>Now that a lot of people have asked me for some good resources on DP and I could find only a few good resources to give the beginners a real boost, I decided to write this basic DP tutorial here. But before we go deep into it, I want to make it clear that the only way to master DP is a lot of practice. The more you solve, the better you get.</p>\n\n<p>DP is an ART. It’s a way of thinking. It’s more like learning to see the same thing from a different angle. It takes some time to get used to, that’s why practicing without getting disheartened is the key to mastering DP.</p>\n\n<p>Prerequisites are\n  1. <em>iteration over multidimensional arrays</em>\n  2. <em>recursion</em>\n  3. <em>basic knowledge of mathematical notations</em></p>\n\n<p>Let’s start with some guidelines on what to think and what not to think and when to use DP. Let’s start with training the mind for seeing things from a different angle.</p>\n\n<ol><li><p>Whenever you see that a problem is minimizing or maximizing a variable by choosing some values in some order over a sequence of values, close your eyes mates and go for DP straight away. In other words, if you are to make a decision about which value in an array should you choose so that the final result after choosing all values in that array will be minimum or maximum, then it’s a DP problem.</p></li><li><p>When you solve a DP problem, the trick is “<strong>Don’t think too much, because the solution is always hidden in the problem</strong>”. Believe in this zen principle and you’ll be good to go and DP will be a piece of cake for you. Most beginners make this mistake of thinking too much, only because they thought the problem was difficult and hence only a complex solution will solve it. But in fact DP is much simpler than their imaginations, so evidently they fail to see the DP solution even if it flutters under their noses.</p></li><li><p><strong>Before you start coding, formulate the problem (<em>not the solution</em>) mathematically on a piece of paper</strong>. Because like I said, the problem is itself the solution.</p></li></ol>\n\n<h4>PROBLEM 1</h4>\n\n<p>I am to count from 1 to N. But I follow a special rule of counting, I can count either 2<em>x or 3</em>x or x+1 after I count x. I always start counting from 1. Now what is the minimum number of steps required to count to N.</p>\n\n<p>Here is the example of this counting : If I want to count till 7, I can count like the following:</p>\n\n<pre><code>1 2 3 4 5 6 7\n1 2 4 5 6 7\n1 2 3 6 7\n1 3 6 7\n1 2 6 7</code></pre>\n\n<p>In this case the minimum number of steps is 4.</p>\n\n<p><strong>Now let’s analyze this problem</strong>. Here we are asked to choose which number to count after x, such that we will reach N in minimum number of steps. Notice that, we are presented with a choice at a point and we have to make the choice in such a way that the next of our choices will give us the optimal result. So, this is a DP problem.</p>\n\n<p>You might be tempted to think that the fastest way to reach N would be to count x<em>3 after x whenever possible. If x</em>3 &gt; N, then try to count x<em>2 and if x</em>2 &gt; N, then simply keep counting x+1. That’s the greedy way to solve this problem. And this greedy algorithm does not always work. For example if I am to count till 8, the greedy way will be to count like 1 3 6 7 8 (5 steps). But the optimal way would be 1 2 4 8 (4 steps). Another example, count till 13 :  greedy way 1 3 9 10 11 12 13 (7 steps), optimal way 1 3 6 12 13 (5 steps).</p>\n\n<p>Now that we have established greedy algorithm won’t work here, let’s analyze why it does not work. It does not work, because we have assumed that taking x<em>3 and x</em>2 and x+1 in the preferential order will solve the problem. We have not considered what the next choices can be before making the current choice. We have not considered that if we take x<em>3 after x, then will it be optimal ? Or it would be more optimal to take x</em>2 and then x<em>2</em>2 and so on.</p>\n\n<p>Now let’s start solving it.</p>\n\n<p><em>Rule-1 :  Don’t think much. Rule-2 : The solution is in the problem. Rule-3 : Formulate the problem first.</em></p>\n\n<p><strong>Formulating the problem</strong> : Let’s see what the problem asks us to do in a mathematical manner.</p>\n\n<p>Let <code>f(x) = minimum number of steps required to count to x.</code>\nEvidently <code>f(1) = 1</code>.\nAnd <code>f(x) = min( f(x-1) , f(x/2) , f(x/3) ) + 1</code> (means, if we have already counted till x-1 or x/2 or x/3, then we can reach x in just one step. We just have to find out whether it&#39;s faster to reach x-1 or x/2 or x/3. If x-1 is faster to reach than x/2 and x/3, then counting to x-1 and the counting x will definitely take less steps than counting to x/2 then x, or counting to x/3 then x.)</p>\n\n<p>if <code>x%2 != 0</code>, we do not consider <code>f(x/2)</code> in the above expression, if <code>x%3 != 0</code> then we do not consider <code>f(x/3)</code> in the above expression. Because if <code>x%2 != 0</code>, then <code>x/2</code> would not be an integer and <code>f(x)</code> is defined only for integers. Same for <code>f(x/3)</code>.</p>\n\n<p>So, now we have represented the problem as a mathematical function, whose value we need to find. Now all we need to do is the find an efficient way of calculating f(N), which is our solution.</p>\n\n<p>As we can see, the function <code>f</code> is a recursive function. So, we can simply implement it as a recursion in our language of choice and it should work correctly. But pure recursion will be slow when N is large.</p>\n\n<p>But, so far, you can see that, we have thought nothing complex, nothing beyond the things mentioned in the problem itself, and we have a solution. That too a recursive solution. And as you must be knowing, every DP has its recursive definition. We just found the recurrence relation for our DP.</p>\n\n<p>Let’s see, why pure recursion is slow :  I want to find <code>f(7)</code>.</p>\n\n<pre><code>f(7) = f(6) + 1    [as 7/2 and 7/3 are not integers]\nf(6) = min ( f(5), f(3), f(2) ) + 1\nf(5) = f(4) + 1\nf(4) = min ( f(3) , f(2) ) + 1\nf(3) = min( f(2), f(1) ) + 1\nf(2) = f(1) + 1\nf(1) = 1</code></pre>\n\n<p>As you can see, in pure recursion, we will have to calculate <code>f(3)</code> and <code>f(2)</code> more than once. First during <code>f(6)</code> we call <code>f(5)</code> and it calls <code>f(4)</code> which calls <code>f(3)</code> and <code>f(2)</code>. When <code>f(4)</code> and <code>f(5)</code> have returned and we are back in <code>f(6)</code>, we call <code>f(3)</code> and <code>f(2)</code> again.  Now that&#39;s a waste of time and resources, because the value of <code>f(2)</code> and <code>f(3)</code> do not change between the calls from <code>f(4)</code> and <code>f(6)</code>.</p>\n\n<p>Hence, pure recursion is slow. But what if we calculate the values of <code>f(x)</code> when needed for the first time and store it in an array and the next time it’s needed we simply look up the array and return the value without really calculating it all over again ?</p>\n\n<p>That would be a much faster way to calculate <code>f(N)</code>. And this way is known as <strong>memorization aka top-down DP</strong>. Let’s now see, how the above idea can be implemented in programming. (in C++ like pseudo code).</p>\n\n<pre><code>int memory[N+1];    // global array, all values initialized to 0\nmemory[1] = 1;     // because f(1) = 1\nint f( int x ){\n     /* if f(x) is calculated and stored in memory, i.e the value in memory[x]\n        is not the default value 0, then just return it without calculation */\n      if ( memory[x] != 0 ) return memory[x];\n      /* otherwise calculate it recursively */\n      int result = INFINITY;\n      if ( x%2 == 0 )\n          result = min (result, f(x/2) );\n      if ( x%3 == 0 )\n          result = min (result, f(x/3) );\n      result = min (result, f(x-1) );\n      result = result + 1;\n      /* now store the result in the array for future use and return */\n      memory[x] = result;\n     return result;\n}</code></pre>\n\n<p>Makes sense ? If not, pause a bit here and read the pseudo code above. Try to imagine how it works during subsequent calls.</p>\n\n<p>Just being able to solve a problem using top-down DP aka memorization is enough in most of the cases. But, when the dataset if too large, the number of recursive calls might result in a function stack overflow error. Normally reported as a case of SIGSSEV or more commonly segmentation fault. If you use Python, in such cases you’ll get a call stack overflow error. Hence it’s important to learn how to solve the DP problems without recursion. That is called “<strong>Bottom-up DP</strong>” . </p>\n\n<p><em>The bottom-up approach requires a little bit more thinking, but always results in more memory efficient, faster and often less lines of code</em>. The idea is, if we are calculating each value only once and then reusing that value in subsequent calls, why not calculate them bottom-up rather than recursively calling them.</p>"
}